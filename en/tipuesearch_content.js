var tipuesearch = {"pages":[{"title":"Nightmare before Easter","text":"Easter is a holiday whose time is determined with an unnecessarily complicated rule. The first Sunday after the first full moon in Spring. Most people have no other choice than to look its date up in a calendar and trust in the calendar manufacturer. But not anymore! I will stick it to Big Calendar and reveal the secret formula to calculate the date of easter! from datetime import date def easter ( year : int ) -> date : y = year g = y % 19 + 1 # golden number c = y // 100 + 1 # century x = ( 3 * c ) // 4 - 12 # correction: dropped leap years z = ( 8 * c + 5 ) // 25 - 5 # correction: synchronize with moon's orbit d = ( 5 * y ) // 4 - x - 10 # find sunday e = ( 11 * g + 20 + z - x ) % 30 # epact if e == 25 and g > 11 or e == 24 : e += 1 n = 44 - e # full moon in march if n < 21 : n += 30 n = n + 7 - ( d + n ) % 7 # advance to next sunday month , day = ( 4 , n - 31 ) if n > 31 else ( 3 , n ) return date ( year , month , day ) My favorite thing about it is that each line becomes more horrendous than the previous. This algorithm was developed by Lilius and Clavius at the end of the 16th Century. I became aware of it through a mention in an exercise in Donald Knuth's The Art of Computer Programming 1 (Third edition, p. 159f).","tags":"Code","url":"https://blog.schawe.me/en/easter.html","loc":"https://blog.schawe.me/en/easter.html"},{"title":"git subtree","text":"Who does not know this common situation: We have a new Idea to extend our existing Project old . So we create a subdirectory newIdea in the corresponding repository. It turns out that the idea was so good that it would also be useful outside of the project old . It would be sensible to create a new repository new which should only contain the subdirectory newIdea . In fact, this problem seems to be so common that there is a special git subcommand since 2012 for this purpose (and more complicated cases): git subtree New repository from subdirectory old/ ├─ newIdea/ │ ├─ lib.rs ├─ main.rs So inside the directory old we execute the following command: git subtree split --prefix = newIdea/ --branch = onlyNewIdeaBranch This creates a new Branch onlyNewIdeaBranch which only contains the contents of newIdea , i.e., a new root directory. So this branch has a newly written history consisting only of commits with influence on files below of newIdea/ . Now we can create the new repository new and pull the newly created branch.Branch pullen. cd .. ; mkdir new ; cd new git init git pull ../alt onlyNewIdeaBranch Maybe we want to delete the newIdea subdirectory from the old repository. Probably we have to change infrastructure code in the new repository. old/ ├─ main.rs new/ ├─ lib.rs Move a subdirectory into an existing repository Possibly we notice that the code would fit better into an existing repository instead of a new one? Perhaps because we are in the process of moving our code into a monorepo? No problem at all! old/ ├─ newIdea/ │ ├─ lib.rs ├─ main.rs monorepo/ ├─ project1/ ├─ project2/ We already created the onlyNewIdeaBranch , which we want to move into the subdirectory goodIdea of the monorepo . Again, we can solve it with git subtree : cd monorepo git branch withGoodIdeadBranch git checkout withGoodIdeadBranch git subtree add --prefix = goodIdea/ ../old onlyNewIdeaBranch As soon as we ensured that our new Branch withGoodIdeadBranch looks good and we modified the infrastructure code, we can merge it into main. old/ ├─ neueIdee/ │ ├─ lib.rs ├─ main.rs monorepo/ ├─ project1/ ├─ project2/ ├─ goodIdea/ │ ├─ lib.rs","tags":"Snip","url":"https://blog.schawe.me/en/git-subtree.html","loc":"https://blog.schawe.me/en/git-subtree.html"},{"title":"Perfect Snake","text":"I like the game snake — not so much playing it, but implementing it. The natural consequence is an autopilot. This way I can just watch instead of playing. On the German version of this blog, there are already quite a few implementations with different heuristics, but nothing particularly good at playing Snake. But now I present an autopilot which can (at least sometimes) play a perfect game of Snake. In case this gif does not convince you, this autopilot can run directly in the browser at snake.schawe.me . So, how does it work? Neural Networks If one does not know how to solve something, try to make a neural net come up with a solution. One example of this applied to classic Atari games was this paper , from ten years ago. We will apply this idea of reinforcement learning to snake in this post (but of course others have done this already [ 8 , 9 ]). The fundamental idea of reinforcement learning is quite simple. Just reward the model for good decision, such that it may learn to make good decisions. So here we will use the score defined as the length of the snake at the end of the game as the objective which is maximized by good decisions. Fortunately, there is already a lot of literature how reinforcement learning can be implemented. We will use the actor-critic approach. So we construct a neural network which takes the current state of the game as input and splits into two heads. One head is the Actor with 3 outputs, which correspond to the next action to take: \"right\", \"left\" or \"straight ahead\". The other head is the Critic with one output representing an estimate of how long the snake can grow from the current situation. For training a full game is played by following the advice of the Actor plus a bit of noise to explore new strategies. Then the Critic is trained with all encountered game states to produce estimates for the final score, which should predict the score that was indeed reached. For training the Actor, we take states of the game, make a different decision and ask the Critic how good the resulting situation is. Depending on the estimated quality, we teach the actor to make this decision more or less often. So Actor and Critic help each other at getting better and the common part of the neural net should gain an \"Understanding\" of the game which both can base their output on. Ingenious! Technical Trivialities My Implementation uses the Python libraries Keras and Tensorflow for training and multiJSnake (German post) as the environment . It is a strange decision to implement the environment in Java. The reason is that it already existed and the combination offered the opportunity to write a post on the blog of my employer . For this post, we will just treat the environment as a black box, which enforces the rules of Snake. Lokal Information One of the most important decisions when designing the model is to determine the nature of the input. The simplest option, which is quite suited for testing, is using the local information around the head of the snake: three neurons (0 or 1) indicating whether the field right, left and ahead are occupied by a wall or the snake body (and eight more for the diagonals and two fields, left, right, ahead and behind for a bit more farsightedness). Also we have to indicate where the food is, which we solve with 4 further neurons (0 or 1) representing whether the food is left, right, in or against the direction of the snake's movement. Behind the input we build a fully connected layer and behind that we connect directly the two heads. And after a few thousand training games the snake moves directly towards the food and avoids itself. But it is not yet clever enough to avoid catching itself in loops. Well, even the heuristic of rsnake (German post) was better. Global Information To avoid the snake trapping itself, we should give it global information of the playing field — it is only fair, since humans do see the whole field, too. But even with a $10 \\times 10$ field, there would be at least 100 input neurons, such that fully connected layers would lead to very large models. Instead, convolutional neural networks seem like a very good fit to solve this problem, especially since our input is of two-dimensional nature. To make life for our artificial intelligence a bit easier, we split our playing field in three channels the Head: only the position of the head has a 1, otherwise 0 the body: the positions of the body have a value corresponding to the number of timesteps they will be occupied the food: only the position of the food has a 1, otherwise 0 This is not even an advantage for the snake, since a human player also sees with three color channels. And to make life for our snake even easier, we change the output of the actor from three relative (left, right, ahead) to four absolute (north, east, south, west) directions. This model layout deserves to be called deep learning . The other model parameters can be looked up at github.com/surt91/multiJSnake . And after a few tenthousand training games this model works well enough to routinely play perfect games on a $10 \\times 10$ field. And since I only trained it on a $10 \\times 10$ field, it fails on every other size.","tags":"Code","url":"https://blog.schawe.me/en/perfect-snake.html","loc":"https://blog.schawe.me/en/perfect-snake.html"},{"title":"Welcome to my Blog!","text":"Here I publish posts in irregular intervals about things I do or want to be able to look up later. I suggest new visitors to take a look at the following highlights instead of scrolling chronologically. Number of longest increasing subsequences about a academic publication, of which I am co-author, and its central algorithm Perfect Snake presents an implementation of the game snake with a neural net based autopilot. Unfortunately, most content is only available on the German version of this blog . But even if you do not speak German, this post about fractals should be nice to look at anyway.","tags":"Meta","url":"https://blog.schawe.me/en/welcome.html","loc":"https://blog.schawe.me/en/welcome.html"},{"title":"Twitter Profile Background Colors","text":"I collected tweets of $>8‘000‘000$ Twitter users for an academic project. But Twitter does not only give you the tweets, but also many more data like the profile background color of users. It would be a shame to let these data go to waste, so I decided to process them into digital art. I wanted to show all the colors in one picture and group similar colors close to each other. This turned out to be much less trivial than I expected, since the space in which the colors live is the three dimensional RGB cube, but my image is only two dimensional. There is no \"correct\" way to project the colors down. Here, I decided to put a 2D Hilbert curve through the image and paint the colors in the order they are encountered by a 3D Hilbert curve in the RGB cube. Ignoring the two default colors #F5F8FA and #C0DEED , this produces this image: And thanks to the Python packages hilbertcurve and pypng the code needed to generate this image is quite harmless: from math import ceil , sqrt , log2 from hilbertcurve.hilbertcurve import HilbertCurve import png \"\"\" turn an RGB string like `#C0DEED` into a tuple of integers, i.e., coordinates of the RGB cube \"\"\" def str2rgb ( s ): s = s . strip ( \"#\" ) return ( int ( s [ 0 : 2 ], 16 ), int ( s [ 2 : 4 ], 16 ), int ( s [ 4 : 6 ], 16 )) \"\"\" `color_histogram` is a dict mapping an rgb string like `#F5F8FA` to the number of usages of this color \"\"\" def plot_background_colors ( color_histogram , filename = \"colors.png\" ): defaults = { \"F5F8FA\" , \"C0DEED\" } data = { str2rgb ( rgb ): d for rgb , d in color_histogram if rgb not in defaults } # calculate the size of the resulting image # for a 2D Hilbert curve, it mus be square with a width, which is a power of 2 num_pixels = sum ( data . values ()) min_width = ceil ( sqrt ( num_pixels )) exponent = ceil ( log2 ( min_width )) width = 2 ** exponent # output buffer for a `width x width` png, with 4 color values per pixel buf = [[ 0 for _ in range ( 4 * width )] for _ in range ( width )] hc2 = HilbertCurve ( exponent , 2 ) # there are 256 = 2&#94;8 values in each direction of the RGB cube hc3 = HilbertCurve ( 8 , 3 ) sorted_rgbs = sorted ( data . keys (), key = lambda x : hc3 . distance_from_point ( x )) idx = 0 for rgb in sorted_rgbs : for _ in range ( data [ rgb ]): # get the coordinate of the next pixel x , y = hc2 . point_from_distance ( idx ) # assign the RGBA values to the pixel buf [ x ][ 4 * y ] = rgb [ 0 ] buf [ x ][ 4 * y + 1 ] = rgb [ 1 ] buf [ x ][ 4 * y + 2 ] = rgb [ 2 ] buf [ x ][ 4 * y + 3 ] = 255 idx += 1 png . from_array ( buf , 'RGBA' ) . save ( filename ) The input histogram was in my case just a simple SQL query away: SELECT profile_background_color , COUNT ( profile_background_color ) FROM users GROUP BY profile_background_color ;","tags":"Code","url":"https://blog.schawe.me/en/twitter-background.html","loc":"https://blog.schawe.me/en/twitter-background.html"},{"title":"Raspberry Router","text":"You need to connect something with an ethernet cable to the internet, but there is only Wifi and all you have is a Raspberry PI ? No problem, all you need to do is connecting it to the Wifi, plug the ethernet cable in and tell it to forward all traffic from the one interface to the other, as described in the Arch Linux Wiki . sysctl net.ipv4.ip_forward = 1 iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE iptables -A FORWARD -i wlan0 -o eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT iptables -A FORWARD -i eth0 -o wlan0 -j ACCEPT Since our Raspberry is now a router, it should also assign IP addresses to the devices connected to it via DHCP , for example with dnsmasq and the following configuration in /etc/dnsmasq.conf : #disable dns port=0 dhcp-range=192.168.13.50,192.168.13.150,12h bind-interfaces dhcp-option=3,0.0.0.0 dhcp-option=6,1.1.1.1,8.8.8.8 This is also a good opportunity to route all traffic through a VPN , by replacing the wlan0 interface above by the configured VPN interface (e.g. tun0 for OpenVPN or wg0 for WireGuard).","tags":"Snip","url":"https://blog.schawe.me/en/raspberry-router.html","loc":"https://blog.schawe.me/en/raspberry-router.html"},{"title":"inline-python","text":"Use the right tool for the job. In my everyday life, this means writing simulations in Rust and visualize the results in Python. Thanks to inline-python this process works extremely well. use inline_python :: python ; fn main () { let x : Vec < f32 > = ( 0 .. 628 ). map ( | i | i as f32 / 100. ). collect (); let y : Vec < f32 > = x . iter (). map ( | x | x . sin ()). collect (); python ! { import numpy as np from matplotlib import pyplot as plt plt . plot ( ' x , ' y ) plt . show () } } This minimal example is useless of course. But I already used this crate productively to simulate dynamics on a petgraph graph and visualize its state via graph-tool .","tags":"Code","url":"https://blog.schawe.me/en/inline-python.html","loc":"https://blog.schawe.me/en/inline-python.html"},{"title":"Number of longest increasing subsequences","text":"My favorite problems are those which seem simple but exhibit unexpected depth. A prime example is the Traveling Salesperson Problem : It is simple to understand that the garbage truck needs to collect every garbage container, while trying to take the shortest route. But here, I want to talk about the problem of the longest increasing subsequence ( LIS ): For a given sequence of numbers, find the subsequence consisting of increasing numbers, which is longest. This problem is so simple that it was first studied almost as a placeholder by Stanisław Ulam in a book chapter describing the Monte Carlo method. And judging by the google results, it seems to be a common problem posed to university students. I am wondering how many job applicants were distressed when trying to solve it in front of a whiteboard. However, apparently one can write whole books about this problem. It turns out that there are surprising connections to seemingly independent problems. For example, the length $L$ of a LIS of a permutation fluctuates the same way as the distance from the center to the border of a coffee stain or the largest eigenvalues of random matrices . The solution of this problem is not unique: A Sequence can contain multiple longest increasing subsequences. Indeed, their number grows exponentially with the length of the original sequence. ![Different longest increasing subsequences within the same sequence](/img/lis_alternatives.png]{: .invertable} But up to now, there did not exist any results about the precise number of different LIS . A common sentiment is that counting all LIS was infeasible, since there are exponentially many. And that would be true if we would want to enumerate them. But since we only want to now the number, we can use dynamic programming to determine it efficiently. The basic idea is that we calculate for each element that can appear at position $x$ in a LIS of how many increasing subsequences of length $L-x$ it is the first element. This becomes easy thanks to a datastructure encoding which elements can be subsequent in a LIS . For this we extend Patience Sort . Since the algorithm is called after a game of cards, it is adequate to describe it with cards: We write each element of our sequence on a card and sort the deck according to the sequence such that the first element is on top. Then we take cards from the top of the deck. We put the topmost card on the table opening a stack. We put the next card on the first stack whose top card is larger than it or open a new stack right of the currently rightmost stack. Each time we put a card on the table, we also add pointers to all cards of the stack left of the placed card which are smaller. These are the cards which could be its predecessor in a LIS . In the end there are $L$ stacks, where $L$ is the length of the LIS . We can start from the rightmost stack, select an arbitrary element and follow the pointers to build a LIS . If we were only interested in the length , we could disregard all but the top card of every stack and could simply the algorithm: fn lis_len < T : Ord > ( seq : & [ T ]) -> usize { let mut stacks = Vec :: new (); for i in seq { let pos = stacks . binary_search ( & i ) . err () . expect ( \"Encountered non-unique element in sequence!\" ); if pos == stacks . len () { stacks . push ( i ); } else { stacks [ pos ] = i ; } } stacks . len () } But we want more, therefore we annotate each card of the rightmost stack with the number of increasing subsequences of length $x=1$ of which they are the first element, which is trivially 1 for each card. Then we continue with the stack left of it and annotate how many increasing subsequences of length 2 start with them. We can calculate this easily by following the pointers backwards and add up the annotations of all predecessor cards. After repeating this and annotating the leftmost stack, we can sum all annotations of the leftmost stack to get the total number of distinct LIS : here $7$. About the behavior for longer sequences from different random ensembles we published an article .","tags":"Phys","url":"https://blog.schawe.me/en/paper-lis2.html","loc":"https://blog.schawe.me/en/paper-lis2.html"},{"title":"compress-pdf","text":"To compress of a pdf with many high resolution images to a sensible filesize (by downscaling and reencoding the images), one can use ghostscript: gs -sDEVICE = pdfwrite -dCompatibilityLevel = 1 .4 -dPDFSETTINGS = /ebook -dEmbedAllFonts = true -dSubsetFonts = true -dNOPAUSE -dQUIET -dBATCH -sOutputFile = output.pdf input.pdf The available presets are screen , ebook , printer , prepress and default . More options can be listed with: gs -sDEVICE = pdfwrite -o /dev/null -c \"currentpagedevice { exch ==only ( ) print == } forall\"","tags":"Snip","url":"https://blog.schawe.me/en/compress-pdf.html","loc":"https://blog.schawe.me/en/compress-pdf.html"},{"title":"smartphone webcam","text":"To use the camera of a smartphone for a video conference on a computer, first an app is needed, which provides the image of the camera as a http stream, for example IP Webcam . For Linux we can use v4l2loopback and ffmpeg to use the stream as a virtual webcam (here for the case that the smartphone has the IP 192.168.1.127 ): sudo modprobe v4l2loopback ffmpeg -i http://192.168.1.127:8080/video -map 0 :v -vcodec rawvideo -vf format = yuv420p -fflags nobuffer -flags low_delay -fflags discardcorrupt -f v4l2 /dev/video2 Additionally, one can use any filter ffmpeg offers, for example a colorkey or chromakey , to use any image background.jpg as a virtual background. Here for the case that a white sheet is used as a \"green screen\": ffmpeg -i images/background.jpg -i http://192.168.1.127:8080/video -vcodec rawvideo -fflags nobuffer -flags low_delay -fflags discardcorrupt -filter_complex \"[1:v]colorkey=0xbbbbbb:0.3:0.2[foregroud];[0:v][foregroud]overlay[composite];[composite]format=yuv420p[out]\" -map \"[out]:v\" -f v4l2 /dev/video2 Similarly, one can use the microphone of the smartphone as audio input for the computer. Here using pulseaudio and gstreamer : pactl load-module module-null-sink sink_name = \"ipwebcam\" pactl set-default-source \"ipwebcam.monitor\" gst-launch-1.0 souphttpsrc location = \"http://192.168.1.127:8080/audio.wav\" is-live = true ! audio/x-raw,format = S16LE,layout = interleaved,rate = 44100 ,channels = 1 ! queue ! pulsesink device = \"ipwebcam\"","tags":"Snip","url":"https://blog.schawe.me/en/smartphone-webcam.html","loc":"https://blog.schawe.me/en/smartphone-webcam.html"},{"title":"Phase Transitions of Traveling Salesperson Problems solved with Linear Programming and Cutting Planes","text":"In this Article, we introduce an ensemble of the Traveling Salesperson problem ( TSP ) that can be tuned with a parameter $\\sigma$ from the trivial case of cities equidistant on a circle to the random Euclidean TSP in a plane. For this ensemble we determine some phase transitions from an \"easy\" phase to a \"not-that-easy\" phase using linear programming. For each of these transitions we present structural properties of the optimal solution, which change at these points characteristically. Since the optimal solution is independent of the solution method, those phase transitions are not only relevant for the specific linear program respectively the solver implementation used to solve them, but a fundamental property of this TSP ensemble. We used the classical linear program of Dantzig: \\begin{align} \\label{eq:objective} &\\text{minimize} & \\sum_i \\sum_{j<i} c_{ij} x_{ij}\\ \\label{eq:int} &\\text{subject to} & x_{ij} &\\in {0,1}\\ %\\mathbb{Z}\\ \\label{eq:inout} & & \\sum_{j} x_{ij} &= 2& & \\forall i \\in V \\ \\label{eq:sec} & & \\sum_{i \\in S, j \\notin S} x_{ij} &\\ge 2& & \\forall S \\varsubsetneq V, S \\ne \\varnothing \\end{align} Here $c_{ij}$ is the distance matrix between all pairs of cities of $V$ and $x_{ij}$ is the adjacency matrix, i.e., $x_{ij} = 1$, if $i$ and $j$ are consecutive in the tour and $x_{ij} = 0$ otherwise. Therefore, the first line minimizes the length of the tour. To avoid that we conclude that $x_{ij} = 0$, i.e., staying at home, is identified as the optimal tour, we introduce the third line to force each city to have two connections, enough to enter and leave. But our salesman is clever and can trick us by choosing $x_{ij} = 0.5$. Since we can not interpret this, we introduce line 2 to force all $x_{ij}$ to integers. Still valid are two unconnected tours, which we forbid with the fourth line, the subtour elimination constraints . Well, the careful reader might already see that we defined one constraint for each subset of the cities, which are exponentially many in the number of cities. But we can solve this by starting without this class of constraints and only adding the ones which are actually violated by a solution. The violated ones can luckily be found easily by calculating the minimum cut of the proposed solution. The corresponding constraint can be added and the procedure is repeated until no subtour elimination constraint is violated anymore. So does that mean that we found an efficient algorithm to solve the traveling salesperson problem? No, unfortunately we can not claim the Millenium Prize yet. There is no known algorithm which can efficiently solve this problem under the integer constraint. But if we drop this constraint, we can use efficient algorithms of linear programming to solve the relaxation . The resulting length will always be a lower bound on the actual solution and if we, by chance, find an integer solution, we can be sure that it is actually the optimal solution. As the order parameter of the transitions from easy to hard we use the probability that a simplex solver yields an integer, and therefore optimal, solution. Without the Subtour Elimination Constraints, the transition occurs at the point at which the optimal solution deviates from the order of the cities on the initial circle. With the Subtour Elimination Constraints the transition coincides with the point at which the optimal tour changes from a zig-zag course to larger meandering arcs. This is measured by the tortuosity \\begin{align } \\tau = \\frac{n-1}{L} \\sum_{i=1}&#94;{n} \\left( \\frac{L_i}{S_i}-1 \\right). \\end{align } which is maximal at this point. For the tortuosity the tour is divided in $N$ parts of same-sign-curvature. For each part the ratio of the direct end-to-end distance $S_i$ to the length along the arc $L_i$ is summed. So, we detected continuous phase transitions in the hardness of the problem with linear programming and correlated them with structural changes.","tags":"Phys","url":"https://blog.schawe.me/en/paper-tsp-pt.html","loc":"https://blog.schawe.me/en/paper-tsp-pt.html"},{"title":"relay ssh","text":"Connect via a server relay with target . Useful if target is behind a firewall, but reachable from relay . ssh -J user1@relay user2@target This can be combined with other options. This way a port forwarding can be established over which, e.g., sshfs can be used. ssh -L 9999 :localhost:22 -J user1@relay user2@target sshfs user2@localhost:/path /mountpoint -C -p 9999 A combination with reverse-ssh could look like this: ssh -L 9999 :localhost:22 -J user1@relay -p 19999 user2@localhost","tags":"Snip","url":"https://blog.schawe.me/en/relay-ssh.html","loc":"https://blog.schawe.me/en/relay-ssh.html"},{"title":"latexdiff","text":"Visualize the differences between two Latex files. latexdiff old.tex new.tex > diff.tex pdflatex diff.tex And if one is using git anyway, there is an even simpler way to compare a given commit with the current state. latexdiff-vc -r 96deadbeef filename.tex --pdf","tags":"Snip","url":"https://blog.schawe.me/en/latexdiff.html","loc":"https://blog.schawe.me/en/latexdiff.html"},{"title":"reverse ssh","text":"On the computer target behind a firewall, in which you want to login in the future, do ssh -f -N -R 0 .0.0.0:19999:localhost:22 user@server server need to be reachable and needs to have the following option set in /etc/ssh/sshd_config GatewayPorts yes Now any client can reach target with ssh -p 19999 user@server This can also used for, e.g., sshfs sshfs -p 19999 user@server:folder ~/sshfs","tags":"Snip","url":"https://blog.schawe.me/en/reverse-ssh.html","loc":"https://blog.schawe.me/en/reverse-ssh.html"},{"title":"png2gif","text":"Convert a folder of .png into an animated .gif . convert -delay 30 -loop 0 -layers Optimize *.png out.gif Naturally, this works not olny for .png and all other options of Imagemagick can be used as well. convert -resize 256x256 \\> -delay 30 -loop 0 -layers Optimize *.svg out.gif","tags":"Snip","url":"https://blog.schawe.me/en/png2gif.html","loc":"https://blog.schawe.me/en/png2gif.html"},{"title":"png2vp9","text":"Convert a folder of .png files into a weboptimized VP9 , which is supported by all important Browsers . ffmpeg -f image2 -pattern_type glob -i \"img*.png\" -c:v libvpx-vp9 -pass 1 \\ -b:v 1000K -threads 1 -speed 4 -tile-columns 0 -frame-parallel 0 \\ -auto-alt-ref 1 -lag-in-frames 25 -g 9999 -aq-mode 0 -an -f null - ffmpeg -f image2 -pattern_type glob -i \"img*.png\" -c:v libvpx-vp9 -pass 2 \\ -b:v 1000K -threads 1 -speed 0 -tile-columns 0 -frame-parallel 0 \\ -auto-alt-ref 1 -lag-in-frames 25 -g 9999 -aq-mode 0 -c:a libopus -b:a 64k \\ -f webm video.webm For maximum compatibility create a MP4 as fallback. ffmpeg -an -f image2 -pattern_type glob -i \"img*.png\" -vcodec libx264 \\ -pix_fmt yuv420p -profile:v baseline -level 3 video.mp4 Embed with: < video > < source src = \"path/to/video.webm\" type = \"video/webm; codecs=vp9,vorbis\" > < source src = \"path/to/video.mp4\" type = \"video/mp4\" > </ video >","tags":"Snip","url":"https://blog.schawe.me/en/png2vp9.html","loc":"https://blog.schawe.me/en/png2vp9.html"},{"title":"optipng","text":"Optimize .png images. Smaller size, no quality loss. optipng -o7 *.png","tags":"Snip","url":"https://blog.schawe.me/en/optipng.html","loc":"https://blog.schawe.me/en/optipng.html"},{"title":"png2mp4","text":"Convert a folder with enumerated .png files into a x264 Video i a .mp4 container with a given frame rate. ffmpeg -f image2 -pattern_type glob -framerate 60 -i \"img*.png\" -vcodec libx264 vid.mp4","tags":"Snip","url":"https://blog.schawe.me/en/png2mp4.html","loc":"https://blog.schawe.me/en/png2mp4.html"},{"title":"svg2png","text":"Convert .svg into .png with white background. inkscape -z -b \\\" #fff\\\" -e img.png -h 1080 img.svg Or a complete folder: for i in *.svg do inkscape -z -b \\\" #fff\\\" -e $(basename -s .svg $i).png -h 1080 $i done","tags":"Snip","url":"https://blog.schawe.me/en/svg2png.html","loc":"https://blog.schawe.me/en/svg2png.html"},{"title":"ssh password","text":"Change the password of your SSH keypair. ssh-keygen -f id_rsa -p","tags":"Snip","url":"https://blog.schawe.me/en/ssh-password.html","loc":"https://blog.schawe.me/en/ssh-password.html"}]};