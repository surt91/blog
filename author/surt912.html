<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>möchte­gern­geek - Articles by surt91</title>
<meta content="Dinge, die ich für hübsch, praktisch oder interessant halte." name="description"/>
<meta content="Hendrik Schawe" name="author"/>
<meta content="Hendrik Schawe" name="copyright"/>
<meta content="#3d4f5d" name="theme-color"/>
<link href="/manifest.json" rel="manifest"/>
<link href="/favicon.ico" rel="icon" type="image/x-icon"/>
<!-- Add to home screen for Safari on iOS-->
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="default" name="apple-mobile-web-app-status-bar-style"/>
<meta content="möchtegerngeek" name="apple-mobile-web-app-title"/>
<link href="/extra/icons/icon-152x152.png" rel="apple-touch-icon"/>
<!-- Add to home screen for Windows-->
<meta content="/extra/icons/icon-152x152.png" name="msapplication-TileImage"/>
<meta content="#b0cadb" name="msapplication-TileColor"/>
<meta content="möchte­gern­geek" property="og:site_name"/>
<meta content="Hendrik Schawe" property="og:article:author"/>
<meta content="article" property="og:type"/>
<meta content="summary" name="twitter:card"/>
<meta content="https://blog.schawe.me/img/logo.png" property="og:image"/>
<meta content="https://blog.schawe.me/img/logo.png" name="twitter:image"/>
<link href="https://blog.schawe.me/author/surt912.html" hreflang="de" rel="alternate">
<link href="https://blog.schawe.me/en/author/surt912.html" hreflang="en" rel="alternate">
<link href="https://blog.schawe.me/author/surt912.html" hreflang="x-default" rel="alternate">
<link href="/theme/webassets-external/6fc8b5d0286641a8981481d8734adb14_pure-min.css" rel="stylesheet" type="text/css"/>
<link href="/theme/webassets-external/cd1fc9b8f4fd6935866873d6d3cfad1b_grids-responsive-min.css" rel="stylesheet" type="text/css"/>
<link href="/theme/css/blog.css" rel="stylesheet" type="text/css"/>
<script async="" src="/theme/js/mathjax-config.js"></script>
<script async="" crossorigin="anonymous" data-search-pseudo-elements="" integrity="sha512-RXf+QSDCUQs5uwRKaDoXt55jygZZm2V++WUZduaU/Ui/9EGp3f/2KZVahFZBKGH0s774sd3HmrhUy+SgOFQLVQ==" referrerpolicy="no-referrer" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/js/all.min.js"></script>
<!-- Preload the other fonts early -->
<link as="font" crossorigin="anonymous" href="/theme/woff2/Merriweather-12ptRegular.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/FiraSans-Regular.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/FiraSans-Bold.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/Merriweather-12ptItalic.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/firacode-regular.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/firacode-bold.woff2" rel="prefetch" type="font/woff2"/>
<link href="https://blog.schawe.me/feeds/all.atom.xml" rel="alternate" title="möchte­gern­geek - Full Atom Feed" type="application/atom+xml">
</link></link></link></link></head>
<body>
<div class="pure-g" id="layout">
<div class="sidebar pure-u-1 pure-u-lg-1-4">
<div class="header">
<h1 class="brand-title"><a href="https://blog.schawe.me">möchte­gern­geek</a></h1>
<nav class="nav">
<ul class="nav-list container">
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/en/"><i class="fa fa-globe"></i> en</a>
</li>
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/categories.html">Kategorien</a>
</li>
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/tags.html">Tags</a>
</li>
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/archives.html">Archiv</a>
</li>
</ul>
</nav>
<div class="container">
<a class="sidebar-social-links" href="https://hendrik.schawe.me" rel="noopener" target="_blank" title="Ich">
<i class="fas fa-user sidebar-social-links"></i>
</a>
<a class="sidebar-social-links" href="https://github.com/surt91" rel="noopener" target="_blank" title="GitHub">
<i class="fab fa-github sidebar-social-links"></i>
</a>
<a class="sidebar-social-links" href="mailto:hendrik.schawe+blog@gmail.com" rel="noopener" target="_blank" title="Email">
<i class="fas fa-envelope sidebar-social-links"></i>
</a>
<a class="sidebar-social-links" href="https://twitter.com/surt91" rel="noopener" target="_blank" title="Twitter">
<i class="fab fa-twitter sidebar-social-links"></i>
</a>
</div>
<div class="container">
<form action="https://blog.schawe.me/search.html" class="pure-form">
<fieldset>
<input aria-label="Suche" class="search-query" id="tipue_search_input" name="q" placeholder="Suche" type="text"/>
</fieldset>
</form>
</div>
</div>
</div>
<div class="content pure-u-1 pure-u-lg-3-4">
<div class="posts">
<article class="post">
<header>
<h2 class="post-title">
<a href="https://blog.schawe.me/analog-digital-analoges-thermometer.html"> Analog-Digital-Analoges Thermometer  </a>
</h2>
<div class="post-meta">
<time class="post-time" datetime="2022-10-03T15:18:00+02:00">03.10.2022</time>
<span class="category category-tech">
<a href="https://blog.schawe.me/categories.html#tech-ref">Tech</a>
</span>
<span class="tags-in-article">
<span class="tag">
<a href="https://blog.schawe.me/tags.html#bild-ref">Bild</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#c-ref">C</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#code-ref">Code</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#microcontroller-ref">Microcontroller</a>
</span>
</span>
</div>
</header>
<div class="post-content">
<p>Ich habe mir ein analoges Voltmeter zugelegt und möchte es als Thermometer benutzen.</p>
<p>Da der Widerstand von Metallen mit der Temperatur steigt, kann man Temperatur relativ gut messen, indem man
einen <a href="https://de.wikipedia.org/wiki/Platin-Messwiderstand">kalibrierten Widerstand</a> misst.
Daher kann man theoretisch mit einem Multimeter auch die Temperatur messen. (In der Praxis wird dies
bei Multimetern allerdings in der Regel mithilfe eines <a href="https://de.wikipedia.org/wiki/Thermoelement#Seebeck-Effekt">anderen Effektes</a> erledigt.)</p>
<p>Da ich mir aber keine Gedanken darüber machen möchte, wie ich eine Schaltung aussehen müsste, um <span class="math">\(15°\mathrm{C}\)</span>
in <span class="math">\(1.5 \mathrm{V}\)</span> umzusetzen (vielleicht würde eine <a href="https://de.wikipedia.org/wiki/Br%C3%BCckenschaltung">Brückenschaltung</a>
funktionieren?), wähle ich den einfachen Weg mit einer Reihe integrierter Schaltkreise und einem Microcontroller.</p>
<p><img alt="Schaltplan meines Analog-Digital-Analog-Thermometers" src="/img/analogue_temperature_circuit.svg"/></p>
<p>Hier ist ein günstiger <span class="caps">DS18B20</span> Temperatursensor, der von einem <span class="caps">ESP8266</span> ausgelesen wird. Dieser steuert dann einen
<span class="caps">MCP4725</span> Digital-Analog-Wandler so an, dass er eine Spannung ausgibt, deren Wert in Volt ein Zehntel der gemessenen
Temperatur ist. Diese Spannung wird dann von meinem alten Voltmeter gemessen und angezeigt. Hier ist es also gerade <span class="math">\(24°\mathrm{C}\)</span>.</p>
<p><a href="/img/analogue_temperature.webp"><img alt="Foto meines Analog-Digital-Analog-Thermometers" height="1200" src="/img/analogue_temperature1200.webp" width="1200"/></a></p>
<p>Hier ist übrigens der simple Code, der beispielsweise mit der Arduino <span class="caps">IDE</span> auf einen <span class="caps">ESP8266</span> geflasht werden kann:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Wire.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Adafruit_MCP4725.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;OneWire.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;DallasTemperature.h&gt;</span>

<span class="cp">#define ONE_WIRE_BUS D4</span>
<span class="cp">#define MCP4725In A0</span>

<span class="n">Adafruit_MCP4725</span><span class="w"> </span><span class="n">MCP4725</span><span class="p">;</span>

<span class="n">OneWire</span><span class="w"> </span><span class="nf">oneWire</span><span class="p">(</span><span class="n">ONE_WIRE_BUS</span><span class="p">);</span>
<span class="n">DallasTemperature</span><span class="w"> </span><span class="nf">DS18B20</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oneWire</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">setup</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>

<span class="w">    </span><span class="n">DS18B20</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// 0x60 is the I2C address of my MCP4725A0</span>
<span class="w">    </span><span class="n">MCP4725</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mh">0x60</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span><span class="w"> </span><span class="nf">getTemperature</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">DS18B20</span><span class="p">.</span><span class="n">requestTemperatures</span><span class="p">();</span>
<span class="w">      </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DS18B20</span><span class="p">.</span><span class="n">getTempCByIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">      </span><span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">temp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">85.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="mf">-127.0</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">setVoltage</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">voltageOut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="o">*</span><span class="mi">4096</span><span class="o">/</span><span class="mf">3.3</span><span class="p">;</span>
<span class="w">    </span><span class="n">MCP4725</span><span class="p">.</span><span class="n">setVoltage</span><span class="p">(</span><span class="n">voltageOut</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// read it for testing and maybe calibrating</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">adcInput</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">analogRead</span><span class="p">(</span><span class="n">MCP4725In</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">voltageIn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">adcInput</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">3.3</span><span class="w"> </span><span class="p">)</span><span class="o">/</span><span class="w"> </span><span class="mf">1024.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Expected Voltage: "</span><span class="p">);</span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>

<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Measured Voltage: "</span><span class="p">);</span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">voltageIn</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">temperature</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getTemperature</span><span class="p">();</span>
<span class="w">    </span><span class="n">setVoltage</span><span class="p">(</span><span class="n">temperature</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// send temperature to the serial console</span>
<span class="w">    </span><span class="n">dtostrf</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">temperatureString</span><span class="p">);</span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">temperatureString</span><span class="p">);</span>

<span class="w">    </span><span class="n">delay</span><span class="p">(</span><span class="mf">1e3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</div>
</article>
<article class="post">
<header>
<h2 class="post-title">
<a href="https://blog.schawe.me/heimkinoautomatisierung.html"> Heimkinoautomatisierung  </a>
</h2>
<div class="post-meta">
<time class="post-time" datetime="2022-07-30T17:30:00+02:00">30.07.2022</time>
<span class="category category-tech">
<a href="https://blog.schawe.me/categories.html#tech-ref">Tech</a>
</span>
<span class="tags-in-article">
<span class="tag">
<a href="https://blog.schawe.me/tags.html#esphome-ref">ESPHome</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#home-assistant-ref">Home Assistant</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#microcontroller-ref">Microcontroller</a>
</span>
</span>
</div>
</header>
<div class="post-content">
<p>Ich habe seit langem einen Beamer statt eines Fernsehers, was einige Vorteile
mit sich bringt: ein sehr großes Bild, kein im Weg stehender Fernseher und
die perfekte Motivation Hausautomatisierung in Angriff zu nehmen. Schließlich
ist der Ablauf, bevor ein Film starten kann, durchaus aufwendig:</p>
<ol>
<li>Die Jalousien werden geschlossen.</li>
<li>Die Leinwand fährt herunter.</li>
<li>Der <span class="caps">AV</span>-Receiver wird angeschaltet.</li>
<li>Der Beamer startet.</li>
</ol>
<p>Tatsächlich hatte ich vor Jahren einen selbstgeschriebenen Python-Server auf
einem Raspberry Pi aufgesetzt, der diese Steuerung übernommen hat. Aber vor kurzem
habe ich ihn ersetzt durch die Anbindung von einem <span class="caps">ESP</span> 8266 mittels
<a href="https://esphome.io/"><span class="caps">ESP</span> Home</a> an <a href="https://www.home-assistant.io/">Home Assistant</a>.
In meinem Setup kommt von Infrarot (<span class="caps">IR</span>) Fernbedienung über 433 MHz Funk (<span class="caps">RF</span>) und Transistoren,
die über Fernbedienungskontakte gelötet sind, bis zu einer seriellen <span class="caps">RS232</span> Schnittstelle
alles vor. Es sollte also für jeden Leser etwas dabei sein.</p>
<h2>Die Jalousien</h2>
<p>Meine Jalousien wurden ursprünglich per Hand mit einem Gurt geöffnet und geschlossen.
Der einfachste Weg solche Rollläden weniger manuell zu machen, sind nachrüstbare Gurtwickler,
die die Muskelkraft durch einen Servomotor ersetzen. Ich habe mir einen relativ günstigen
elektrischen Gurtwickler mit einer 433 MHz Fernbedienung gekauft. Der Plan war eigentlich
mit einem 433 MHz Receiver die Signale aufzuzeichnen und danach mit einem Sender wieder zu schicken.</p>
<p>Blöderweise hat sich (unter Verwendung von Audacity als Offline-Oszilloskop) herausgestellt,
dass sich das Signal bei jedem Knopfdruck ändert — anscheinend nutzen meine Gurtwickler
ein Protokoll mit Schlüssel, was beispielsweise für sicherheitsrelevante Anwendungen wie
Garagentore verwendet wird.</p>
<p>Die einfache Lösung dafür ist, die Fernbedienung auseinander zu bauen und die Taster, die
normalerweise per Hand ausgelöst werden, mit Transistoren zu überbrücken, die dann über
<span class="caps">GPIO</span> Pins ausgelöst werden können.</p>
<p><a href="/img/screen_switch.webp"><img alt="Das ist zwar die Fernbedienung von der Leinwand, aber das Prinzip ist das gleiche und ich habe es versäumt ein Foto von der Jalousien-Fernbedienung zu machen" height="899" src="/img/screen_switch1200.webp" width="1200"/></a></p>
<p>Und die Konfiguration in <span class="caps">ESP</span> Home ist selbsterklärend.</p>
<div class="highlight"><pre><span></span><code><span class="nt">output</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">platform</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">gpio</span>
<span class="w">    </span><span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">blinds_up_pin</span>
<span class="w">    </span><span class="nt">pin</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">D7</span>

<span class="nt">button</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">platform</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">output</span>
<span class="w">    </span><span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">blinds_up</span>
<span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Jalusinen hoch</span>
<span class="w">    </span><span class="nt">icon</span><span class="p">:</span><span class="w"> </span><span class="s">"mdi:roller-shade"</span>
<span class="w">    </span><span class="nt">output</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">blinds_up_pin</span>
<span class="w">    </span><span class="nt">duration</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">300ms</span>
<span class="c1"># skipped blinds down</span>
</code></pre></div>
<h2>Die Leinwand</h2>
<p>Motorisierte Leinwände haben oft einen Eingang für einen 3,5 mm Klinkenstecker, den man direkt mit
dem Beamer verbinden kann. Leider nicht die Leinwand, die ich habe. Aber halb so schlimm, denn
sie hat eine Funkfernbedienung und ich habe ja noch die 433 MHz Hardware, die für die Jalousien
gedacht waren. Und tatsächlich nutzt meine Leinwand ein simples Protokoll — aber auf 315 Mhz.</p>
<p>Sobald wir also einen 315 MHz Transmitter und Receiver haben, können wir die Codes aufzeichnen und die <span class="caps">ESP</span> Home
Konfiguration anpassen. Dafür definieren wir einen <code>remote_transmitter</code> für den passenden <span class="caps">GPIO</span> Pin
und einen <code>switch</code>, der den Code für „herunter fahren“ sendet, die passende Zeit wartet und dann den Code
für „stopp“ sendet. Eine Stolperfalle ist, dass der Code mittels <code>repeat</code> mehrmals gesendet werden muss.</p>
<div class="highlight"><pre><span></span><code><span class="nt">remote_receiver</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">RF315_Recv</span>
<span class="w">    </span><span class="nt">pin</span><span class="p">:</span>
<span class="w">      </span><span class="nt">number</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">D5</span>
<span class="w">      </span><span class="nt">inverted</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">yes</span>
<span class="w">      </span><span class="nt">mode</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">INPUT_PULLUP</span>
<span class="w">    </span><span class="nt">dump</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">all</span>

<span class="nt">remote_transmitter</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">RF315</span>
<span class="w">    </span><span class="nt">pin</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">D1</span>
<span class="w">    </span><span class="nt">carrier_duty_percent</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">100%</span>

<span class="nt">switch</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">platform</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">template</span>
<span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Screen</span>
<span class="w">    </span><span class="nt">icon</span><span class="p">:</span><span class="w"> </span><span class="s">"mdi:projector-screen"</span>
<span class="w">    </span><span class="nt">optimistic</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
<span class="w">    </span><span class="nt">turn_on_action</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">remote_transmitter.transmit_rc_switch_raw</span><span class="p">:</span>
<span class="w">          </span><span class="nt">transmitter_id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">RF315</span>
<span class="w">          </span><span class="nt">code</span><span class="p">:</span><span class="w"> </span><span class="s">'000110110111100111000100'</span>
<span class="w">          </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span>
<span class="w">          </span><span class="nt">repeat</span><span class="p">:</span>
<span class="w">            </span><span class="nt">times</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">10</span>
<span class="w">            </span><span class="nt">wait_time</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">0s</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">delay</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">39.0s</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">remote_transmitter.transmit_rc_switch_raw</span><span class="p">:</span>
<span class="w">          </span><span class="nt">transmitter_id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">RF315</span>
<span class="w">          </span><span class="nt">code</span><span class="p">:</span><span class="w"> </span><span class="s">'000110110111100111001000'</span>
<span class="w">          </span><span class="nt">protocol</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span>
<span class="w">          </span><span class="nt">repeat</span><span class="p">:</span>
<span class="w">            </span><span class="nt">times</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">10</span>
<span class="w">            </span><span class="nt">wait_time</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">0s</span>
<span class="w">    </span><span class="c1"># turn_off_action skipped</span>
</code></pre></div>
<h2>Der <span class="caps">AV</span>-Receiver</h2>
<p>Dies ist die erste Komponente, die nach Plan läuft: Der <span class="caps">AV</span>-Receiver hat eine <span class="caps">IR</span> Fernbedienung
und der Hersteller veröffentlicht die Codes sogar selbst, sodass ich mir das Aufzeichnen sparen kann.
Falls man diesen Luxus nicht that, kann man an den <span class="caps">ESP</span> einen <span class="caps">IR</span> Receiver wie einen <span class="caps">TSOP</span> 4838
anschließen und mit dem <a href="https://esphome.io/components/remote_receiver.html"><code>remote_receiver</code></a> auswerten.</p>
<p>Um die Signale zu senden, reicht eine Infrarotdiode, die ich über einen Transistor schalte.</p>
<p><img alt="Infrarot Sender" height="280" src="/img/ir_esp.svg" width="250"/></p>
<p>Für <span class="caps">ESP</span> Home müssen wir einen weiteren <code>remote_transmitter</code> definieren. Damit die Codes über die <span class="caps">IR</span> Diode
und nicht über den <span class="caps">RF</span> Sender verschickt werden, müssen wir dem Transmitter eine Id zuweisen und diese später
mit <code>transmitter_id</code> referenzieren.</p>
<div class="highlight"><pre><span></span><code><span class="nt">remote_transmitter</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">IR</span>
<span class="w">    </span><span class="nt">pin</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">D2</span>
<span class="w">    </span><span class="nt">carrier_duty_percent</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">50%</span>

<span class="nt">button</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">platform</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">template</span>
<span class="w">    </span><span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">av_on</span>
<span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">AV on</span>
<span class="w">    </span><span class="nt">icon</span><span class="p">:</span><span class="w"> </span><span class="s">"mdi:audio-video"</span>
<span class="w">    </span><span class="nt">on_press</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">remote_transmitter.transmit_pioneer</span><span class="p">:</span>
<span class="w">          </span><span class="nt">transmitter_id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">IR</span>
<span class="w">          </span><span class="nt">rc_code_1</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">0xA51A</span>
<span class="w">          </span><span class="nt">repeat</span><span class="p">:</span>
<span class="w">            </span><span class="nt">times</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">2</span>
<span class="c1"># skipped other buttons</span>
</code></pre></div>
<h2>Der Beamer</h2>
<p>Den Beamer könnte man natürlich auch per <span class="caps">IR</span> steuern, aber mein Modell, der BenQ W1070, hat eine <span class="caps">RS232</span>
Schnittstelle, die nicht nur etwas zuverlässiger als die Infrarotschnittstelle ist, sondern es auch
erlaubt den aktuellen Zustand auszulesen. Dazu können wir bspw. einen <span class="caps">MAX3232</span> an die <span class="caps">UART</span>
Pins anschließen und die Beispielkonfiguration für den custom <code>text_sensor</code> aus der <span class="caps">ESP</span> Home
Dokumentation kopieren.</p>
<div class="highlight"><pre><span></span><code><span class="nt">logger</span><span class="p">:</span>
<span class="w">  </span><span class="c1"># disable logging over uart</span>
<span class="w">  </span><span class="nt">baud_rate</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">0</span>

<span class="nt">uart</span><span class="p">:</span>
<span class="w">  </span><span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">uart_bus</span>
<span class="w">  </span><span class="nt">tx_pin</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1</span>
<span class="w">  </span><span class="nt">rx_pin</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">3</span>
<span class="w">  </span><span class="c1"># choose same value set in the projector settings</span>
<span class="w">  </span><span class="nt">baud_rate</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">9600</span>

<span class="nt">text_sensor</span><span class="p">:</span>
<span class="w">  </span><span class="c1"># this needs the .h file from https://esphome.io/cookbook/uart_text_sensor.html</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">platform</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">custom</span>
<span class="w">    </span><span class="nt">lambda</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|-</span>
<span class="w">      </span><span class="no">auto my_custom_sensor = new UartReadLineSensor(id(uart_bus));</span>
<span class="w">      </span><span class="no">App.register_component(my_custom_sensor);</span>
<span class="w">      </span><span class="no">return {my_custom_sensor};</span>
<span class="w">    </span><span class="nt">text_sensors</span><span class="p">:</span>
<span class="w">      </span><span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="s">"uart_readline"</span>

<span class="nt">switch</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">platform</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">template</span>
<span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="s">"Projector</span><span class="nv"> </span><span class="s">Power"</span>
<span class="w">    </span><span class="nt">icon</span><span class="p">:</span><span class="w"> </span><span class="s">"mdi:projector"</span>
<span class="w">    </span><span class="nt">lambda</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|-</span>
<span class="w">      </span><span class="no">if (id(uart_readline).state == "*POW=ON#") {</span>
<span class="w">        </span><span class="no">return true;</span>
<span class="w">      </span><span class="no">} else if(id(uart_readline).state == "*POW=OFF#") {</span>
<span class="w">        </span><span class="no">return false;</span>
<span class="w">      </span><span class="no">} else {</span>
<span class="w">        </span><span class="no">return {};</span>
<span class="w">      </span><span class="no">}</span>
<span class="w">    </span><span class="nt">turn_on_action</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">uart.write</span><span class="p">:</span><span class="w"> </span><span class="s">"\r*pow=on#\r"</span>
<span class="w">    </span><span class="nt">turn_off_action</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">uart.write</span><span class="p">:</span><span class="w"> </span><span class="s">"\r*pow=off#\r"</span>
</code></pre></div>
<h2>Fazit</h2>
<p>Da dies doch eine ganze Menge Komponenten sind, die ich per Jumper-Kabel an den <span class="caps">ESP</span>
geschlossen habe, ist noch ein Gehäuse nötig. Dazu nutze ich die beste Alternative zu
einem 3D-Drucker: Lego!</p>
<p><a href="/img/heimkinoautomatisierung.webp"><img alt="Alle Komponenten mittels Lego an der Beamerhalterung befestigt" height="1600" src="/img/heimkinoautomatisierung1200.webp" width="1200"/></a></p>
<p>Die Aufhängung des Beamers bietet dabei den optimalen Ort für eine provisorische
Befestigung, die nahe am <span class="caps">RS232</span>-Eingang des Beamers ist und einen guten Blick
auf den <span class="caps">IR</span>-Empfänger des <span class="caps">AV</span>-Receivers hat.</p>
<p>Die gesamte <span class="caps">EPS</span>-Home-Konfigurationsdatei steht auch als
<a href="https://gist.github.com/surt91/dde1e7986cda0177a7b790930edb7230">GitHub Gist</a> bereit.</p>
<p>Das ganze Setup wird abgerundet von einem selbstgebauten Schalter (mit Cherry Blue Switches),
um den Kinomodus zu starten und zu beenden, sowie Home-Assistant-Automatisierungen,
die das Licht kontrollieren: Licht aus wenn der Film startet, Licht gedimmt, wenn er pausiert.</p>
</div>
</article>
<article class="post">
<header>
<h2 class="post-title">
<a href="https://blog.schawe.me/paper-convex-highdim.html"> Convex hulls of random walks in higher dimensions: A large deviation study  </a>
</h2>
<div class="post-meta">
<div>
<span class="doi-details">
                        Hendrik Schawe, Alexander K. Hartmann, Satya N. Majumdar,
                        Physical Review E <b>96</b>, 062101 (2017)
                    </span>
</div>
<time class="post-time" datetime="2022-05-28T16:08:00+02:00">28.05.2022</time>
<span class="category category-phys">
<a href="https://blog.schawe.me/categories.html#phys-ref">Phys</a>
</span>
<span class="tags-in-article">
<span class="tag">
<a href="https://blog.schawe.me/tags.html#bild-ref">Bild</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#physik-ref">Physik</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#veroffentlichung-ref">Veröffentlichung</a>
</span>
</span>
<span class="doi"><a href="https://dx.doi.org/10.1103/PhysRevE.96.062101">doi:10.1103/PhysRevE.96.062101</a></span>
</div>
</header>
<div class="post-content">
<p>Die Frage wie groß das Revier eines Tieres ist, ist in konkreten Fällen für Biologen
interessant und dank <span class="caps">GPS</span>-Sendern kann man es heutzutage sogar empirisch untersuchen. Aus der
Punktwolke der besuchten Orte kann man eine Fläche abschätzen — im einfachsten Fall
indem man die konvexe Hülle um alle besuchten Orte zeichnet.</p>
<p>Als Physiker sind mir echte Tiere zu kompliziert, sodass ich stattdessen annehme,
dass sie punktförmig sind und ihre Bewegung ein <em>Random Walk</em> in einer isotropen
Umgebung ist. Also springen meine idealisierten Tiere unabhängig von ihren bisherigen
Handlungen zu ihrem nächsten Aufenthaltsort — der Abstand vom aktuellen Punkt ist dabei
in jeder Dimension unabhängig und normalverteilt.</p>
<p><em>In jeder Dimension?</em> Ja, genau! Wir wollen schließlich auch das Revierverhalten von
vierdimensionalen Space Whales untersuchen.</p>
<p><img alt="Ein vierdimensionaler Weltraumwal, oder was Stable Diffusion sich darunter vorstellt" height="512" src="/img/SpaceWhale.webp" width="512"/></p>
<p>Spaß beiseite, in dieser Veröffentlichung geht es natürlich eher um fundamentale
Eigenschaften von Random Walks — einer der einfachsten und deshalb am besten
untersuchten Markow-Prozesse. Und zwar im Hinblick auf Large Deviations,
die extrem unwahrscheinlichen Ereignisse, die weit jenseits der Möglichkeiten
von konventionellen Sampling-Methoden liegen. Details hierzu sind am besten
direkt im <a href="https://academic.schawe.me/pdf/2017_convex_highdim_PRE.pdf">Artikel</a> oder mit einer
Menge Hintergrundinformationen und ausführlicher als für ein Blog angemessen
in dem entsprechenden Kapitel und Anhang meiner <a href="https://academic.schawe.me/pdf/dissertation.pdf">Dissertation</a>
nachzulesen. Insbesondere ist dort auch beschrieben wie die geometrischen
Unterprobleme effizient gelöst werden können, auf die wir im Verlauf dieses
Blogposts stoßen werden.</p>
<p>Das Problem eine konvexe Hülle zu finden ist einerseits einfach zu begreifen,
schön geometrisch und sehr gut untersucht. Dadurch sind überraschend viele
Algorithmen bekannt, die unterschiedliche Vor- und Nachteile haben.</p>
<p>Im Folgenden möchte ich deshalb ein paar Methoden vorstellen, wie man effizient
die konvexe Hülle einer Punktmenge bestimmen kann, und dies mit animierten gifs von
Punkten und Strichen visualisieren. Der Code zur Erstellung der Visualisierungen
ist übrigens in Rust geschrieben und auf <a href="https://github.com/surt91/convex_hulls">GitHub</a> zu finden.</p>
<h2>Andrew’s Monotone Chain</h2>
<p>In zwei Dimensionen kann man ausnutzen, dass die konvexe Hülle ein Polygon ist, das
man durch die Reihenfolge der Eckpunkte definieren kann. Die grundlegende Idee ist
also die Punkte im Uhrzeigersinn zu sortieren, in dieser Reihenfolge, mit dem
Punkt ganz links startend, alle zu einem Polygon hinzuzufügen und dabei darauf
zu achten, dass die drei neusten Punkte des Polygons ein negativ orientiertes Dreieck
bilden, also dass sie im „Uhrzeigersinn drehen“. Wenn das nicht der Fall ist,
wird der mittlere Punkt entfernt.</p>
<p><img alt="Sechs Schritte von Andrew's Monotone Chain -- oder Graham Scan" class="invertable" height="1170" src="/img/ch_andrew_steps.webp" width="3440"/></p>
<p>Dies ist übrigens die ursprüngliche Variante, der <em>Graham Scan</em>. Andrew verbesserte
diesen Algorithmus dadurch, dass nicht im Uhrzeigersinn sortiert werden muss, sondern
man lexikographisch nach horizontaler Koordinate (bei Gleichstand entscheidet die
vertikale Koordinate) sortiert. Dann bildet dieser Algorithmus die obere Hälfte der Hülle
und wenn man ihn rückwärts auf die sortierten Punkte anwendet, die untere Hälfte.</p>
<p><img alt="Andrew's Monotone Chain" class="invertable" height="800" src="/img/ch_andrew.gif" width="800"/></p>
<p>Die Komplexität für <span class="math">\(n\)</span> Punkte ist somit <span class="math">\(\mathcal{O}(n \ln n)\)</span> limitiert durch das Sortieren.</p>
<h2>Jarvis March: Gift Wrapping</h2>
<p>Ein Geschenk einzupacken ist ein relativ intuitiver Prozess: Wir bewegen das Papier
so lange herunter, bis wir auf einen Punkt des Geschenkes treffen, wo es hängen bleibt
Dann wickeln wir weiter, bis wir auf den nächsten Punkt stoßen. Dabei streben wir an die
konvexe Hülle zu finden, denn sie ist das Optimum möglichst wenig Papier zu verbrauchen
während wir die Punktwolke einhüllen, die wir verschenken wollen. Und offenbar klappt das
auch in drei Dimensionen!</p>
<p>In einem Computer ist es allerdings einfacher das Geschenkpapier von innen aus der Punktwolke
heraus nach außen zu falten. Für jede Facette testen wir also jeden der <span class="math">\(n\)</span> Punkte in der
Punktwolke darauf, ob er links von unserem Stück Geschenkpapier liegt. Wenn ja, falten wir das
Papier weiter. Sobald wir alle <span class="math">\(n\)</span> Punkte ausprobiert haben, wissen wir, dass das Geschenkpapier
an der richtigen Stelle liegt, sodass anfangen können die nächste Facette mit dem Geschenkpapier
zu bilden indem wir von innen alle Punkte durchtesten.</p>
<p><img alt="Jarvis March: Gift Wrapping" class="invertable" height="800" src="/img/ch_jarvis.gif" width="800"/></p>
<p>Interessanterweise müssen wir also für jeden der <span class="math">\(h\)</span> Punkte, die zur Hülle gehören <span class="math">\(\mathcal{O}(n)\)</span> Punkte
prüfen, sodass die Komplexität abhängig ist vom Ergebnis: <span class="math">\(\mathcal{O}(n h)\)</span></p>
<h2>Chan’s Algorithm</h2>
<p>Wir haben also einen <span class="math">\(\mathcal{O}(n \ln n)\)</span> und einen <span class="math">\(\mathcal{O}(n h)\)</span> Algorithmus kennen gelernt,
aber können wir noch besser werden? Ja! <span class="math">\(\mathcal{O}(n \ln h)\)</span> ist die theoretische untere Komplexitätsgrenze
für 2D konvexe Hüllen. Beispielsweise Chans Algorithmus erreicht diese Komplexität mit einem trickreichen
zweistufigen Prozess.</p>
<p>Zuerst teilt man die Punktwolke in zufällige Untermengen mit jeweils etwa <span class="math">\(m\)</span> Punkten ein. Für jede berechnet
man die konvexe Hülle, bspw. mit Andrews Algorithmus. Dann benutzt man Jarvis March, um die Hülle zu konstruieren,
dabei muss man allerdings nicht mehr alle Punkte durchprobieren, sondern nur noch die Tangenten, die in der Animation
mit grünen Strichen gekennzeichnet sind. Die Tangenten kann man für jede der <span class="math">\(k = \lceil \frac{n}{m} \rceil\)</span> Sub-Hüllen
effizient in <span class="math">\(\mathcal{O}(m)\)</span> bestimmen. Dazu benutzt man einem Algorithmus, der an eine Binärsuche erinnert.
Zusammen hat dies also eine Komplexität von <span class="math">\(\mathcal{O}((n+kh) \ln m)\)</span>.</p>
<p>Aber ich hatte <span class="math">\(\mathcal{O}(n \ln h)\)</span> versprochen. Nun, um das zu erreichen, müssen wir einfach nur <span class="math">\(m \approx h\)</span> wählen.
Aber wie kommen wir an <span class="math">\(h\)</span> bevor wir die Hülle berechnet haben? Der Trick ist, mit einem niedrigen <span class="math">\(m\)</span> zu starten,
dann nur <span class="math">\(m\)</span> Schritte des Jarvis-Teils des Algorithmus durchzuführen und wenn die Hülle dann noch nicht fertig ist
<span class="math">\(m\)</span> zu erhöhen und es wieder von vorne zu beginnen. Damit dieser iterative Teil des Algorithmus nicht unsere Komplexität
erhöht, muss <span class="math">\(m\)</span> schnell genug wachsen, was in der Regel durch Quadrieren des alten Werten erreicht wird.</p>
<p><img alt="Chan's Algorithm" class="invertable" height="800" src="/img/ch_chan.gif" width="800"/></p>
<h2>QuickHull</h2>
<p>Zuletzt möchte ich hier noch QuickHull vorstellen, weil dieser Algorithmus meiner Meinung nach einen sehr hübschen
rekursiven <em>divide and conquer</em> Ansatz verfolgt — ein bisschen wie QuickSort.
In zwei Dimensionen starten wir mit dem Punkt ganz links <span class="math">\(A\)</span> und ganz rechts <span class="math">\(B\)</span>. Dann finden wir den Punkt <span class="math">\(C\)</span> der
am weitesten entfernt ist von der Strecke <span class="math">\(\overline{AB}\)</span> und links von der Strecke ist. Diesen Schritt wiederholen wir
rekursiv auf den Strecken <span class="math">\(\overline{AC}\)</span> und <span class="math">\(\overline{CB}\)</span> (und <span class="math">\(\overline{BA}\)</span> für die untere Hälfte.)</p>
<p><img alt="QuickHull" class="invertable" height="800" src="/img/ch_quickhull.gif" width="800"/></p>
<h2>Mehr Dimensionen</h2>
<p>Aber ich hatte Space Whales versprochen, also können wir uns nicht mit 2D zufrieden geben!
Tatsächlich müssen wir schon beim Verallgemeinern auf 3D aufpassen. Schließlich konnten
wir für 2D die konvexe Hülle als Sequenz von Punkten repräsentieren. Für höhere Dimensionen
müssen wir sie allerdings als Menge von Facetten repräsentieren. Glücklicherweise tauchen
für noch höhere Dimensionen dann keine weiteren Schwierigkeiten mehr auf — abgesehen von der
Grundsätzlichen Schwierigkeit, dass höherdimensionale Gebilde deutlich größere Oberflächen
haben und somit die konvexe Hülle aus deutlich mehr Facetten besteht, sodass die untere Schranke
für die Komplexität für Dimension <span class="math">\(d\)</span> durch <span class="math">\(\mathcal{O}(n^{\lfloor d / 2 \rfloor})\)</span> gegeben ist.</p>
<p>Bevor ich hier QuickHull für <span class="math">\(d=3\)</span> beschreibe, möchte ich darauf hinweisen, dass es die
<a href="http://www.qhull.org/"><code>qhull</code> Implementierung</a> gibt, die sich bspw. auch um die subtilen numerischen
Fehler kümmert, die sich bei sehr spitzen Winkeln einschleichen können.</p>
<p>Grundsätzlich bleibt das Vorgehen gleich: Wir starten mit einem <span class="math">\(d\)</span>-dimensionalen Simplex, also für <span class="math">\(d=3\)</span>
mit einem Tetraeder, dessen Eckpunkte zur konvexen Hülle gehören. Dann führen wir für jede Facette
den rekursiven Schritt durch: Finde den Punkt, der am weitesten <em>vor</em> der Facette (also außerhalb des Tetraeders) ist.
Diesen Punkt nennt man <em>Eye-Point</em>. Denn es reicht jetzt im Gegensatz zum 2D Fall nicht mehr
einfach neue Facetten aus den Rändern und dem neuen Punkt zu bilden. Stattdessen müssen wir alle
Facetten, deren Vorderseite (also Außenseite) wir vom Eye-Point aus sehen können entfernen und
neue Facetten mit dem Horizont und dem <em>Eye-Point</em> bilden. In der Animation unten sind der <em>Eye-Point</em>
sowie die Facetten, die er sieht, rot dargestellt. Der Horizont ist mit schwarzen Strichen gekennzeichnet.</p>
<p>Wird dieser Schritt rekursiv auf alle neu hinzugefügten Facetten angewendet, resultiert die
konvexe Hülle. Und genauso, wenn auch deutlich schwieriger darstellbar, funktioniert es auch
für alle höheren Dimensionen.</p>
<p><img alt="QuickHull" height="1450" src="/img/ch_quickhull3d.gif" width="1450"/></p>
<p>Eine wichtige Anwendung für 3D konvexe Hüllen ist übrigens die Delaunay-Triangulation einer planaren
Punktmenge. Die wiederum kann für eine effiziente Berechnung des <a href="https://blog.schawe.me/relative-neighborhood-graph.html">Relative-Neighborhood-Graphs aus
diesem Post</a> genutzt werden.</p>
</div>
</article>
</div>
<div class="post-navigation">
<nav class="pagination">
<a href="https://blog.schawe.me/author/surt91.html">← Neuer</a>
<span class="separatordot">·</span>
<a href="https://blog.schawe.me/author/surt913.html">Älter →</a>
<br/>
            2 / 18
        </nav>
</div>
</div>
<div id="last-update">
<time datetime="2024-12-27 10:29:03">10:29:03 27.12.2024</time>
</div>
</div>
<script async="" src="/theme/webassets-external/0cf7968c252ead5c096e55c1f7673096_rythm.js"></script>
<script async="" src="/theme/webassets-external/a8b690a4c23c0610ea6538a9352534be_totally_serious_script.js"></script>
<script async="" src="/theme/js/unregister_service_worker.js"></script>
</body>
</html>