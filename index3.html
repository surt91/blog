<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>möchte­gern­geek</title>
<meta content="Dinge, die ich für hübsch, praktisch oder interessant halte." name="description"/>
<meta content="Hendrik Schawe" name="author"/>
<meta content="Hendrik Schawe" name="copyright"/>
<meta content="#3d4f5d" name="theme-color"/>
<link href="/manifest.json" rel="manifest"/>
<link href="/favicon.ico" rel="icon" type="image/x-icon"/>
<!-- Add to home screen for Safari on iOS-->
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="default" name="apple-mobile-web-app-status-bar-style"/>
<meta content="möchtegerngeek" name="apple-mobile-web-app-title"/>
<link href="/extra/icons/icon-152x152.png" rel="apple-touch-icon"/>
<!-- Add to home screen for Windows-->
<meta content="/extra/icons/icon-152x152.png" name="msapplication-TileImage"/>
<meta content="#b0cadb" name="msapplication-TileColor"/>
<meta content="möchte­gern­geek" property="og:site_name"/>
<meta content="Hendrik Schawe" property="og:article:author"/>
<meta content="article" property="og:type"/>
<meta content="summary" name="twitter:card"/>
<meta content="https://blog.schawe.me/img/logo.png" property="og:image"/>
<meta content="https://blog.schawe.me/img/logo.png" name="twitter:image"/>
<link href="https://blog.schawe.me/index3.html" hreflang="de" rel="alternate">
<link href="https://blog.schawe.me/en/index3.html" hreflang="en" rel="alternate">
<link href="https://blog.schawe.me/index3.html" hreflang="x-default" rel="alternate">
<link href="/theme/webassets-external/6fc8b5d0286641a8981481d8734adb14_pure-min.css" rel="stylesheet" type="text/css"/>
<link href="/theme/webassets-external/cd1fc9b8f4fd6935866873d6d3cfad1b_grids-responsive-min.css" rel="stylesheet" type="text/css"/>
<link href="/theme/css/blog.css" rel="stylesheet" type="text/css"/>
<script async="" src="/theme/js/mathjax-config.js"></script>
<script async="" crossorigin="anonymous" data-search-pseudo-elements="" integrity="sha512-RXf+QSDCUQs5uwRKaDoXt55jygZZm2V++WUZduaU/Ui/9EGp3f/2KZVahFZBKGH0s774sd3HmrhUy+SgOFQLVQ==" referrerpolicy="no-referrer" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/js/all.min.js"></script>
<!-- Preload the other fonts early -->
<link as="font" crossorigin="anonymous" href="/theme/woff2/Merriweather-12ptRegular.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/FiraSans-Regular.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/FiraSans-Bold.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/Merriweather-12ptItalic.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/firacode-regular.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/firacode-bold.woff2" rel="prefetch" type="font/woff2"/>
<link href="https://blog.schawe.me/feeds/all.atom.xml" rel="alternate" title="möchte­gern­geek - Full Atom Feed" type="application/atom+xml">
</link></link></link></link></head>
<body>
<div class="pure-g" id="layout">
<div class="sidebar pure-u-1 pure-u-lg-1-4">
<div class="header">
<h1 class="brand-title"><a href="https://blog.schawe.me">möchte­gern­geek</a></h1>
<nav class="nav">
<ul class="nav-list container">
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/en/"><i class="fa fa-globe"></i> en</a>
</li>
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/categories.html">Kategorien</a>
</li>
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/tags.html">Tags</a>
</li>
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/archives.html">Archiv</a>
</li>
</ul>
</nav>
<div class="container">
<a class="sidebar-social-links" href="https://hendrik.schawe.me" rel="noopener" target="_blank" title="Ich">
<i class="fas fa-user sidebar-social-links"></i>
</a>
<a class="sidebar-social-links" href="https://github.com/surt91" rel="noopener" target="_blank" title="GitHub">
<i class="fab fa-github sidebar-social-links"></i>
</a>
<a class="sidebar-social-links" href="mailto:hendrik.schawe+blog@gmail.com" rel="noopener" target="_blank" title="Email">
<i class="fas fa-envelope sidebar-social-links"></i>
</a>
<a class="sidebar-social-links" href="https://twitter.com/surt91" rel="noopener" target="_blank" title="Twitter">
<i class="fab fa-twitter sidebar-social-links"></i>
</a>
</div>
<div class="container">
<form action="https://blog.schawe.me/search.html" class="pure-form">
<fieldset>
<input aria-label="Suche" class="search-query" id="tipue_search_input" name="q" placeholder="Suche" type="text"/>
</fieldset>
</form>
</div>
</div>
</div>
<div class="content pure-u-1 pure-u-lg-3-4">
<div class="posts">
<article class="post">
<header>
<h2 class="post-title">
<a href="https://blog.schawe.me/git-subtree.html"> git subtree  </a>
</h2>
<div class="post-meta">
<time class="post-time" datetime="2022-07-24T17:31:00+02:00">24.07.2022</time>
<span class="languages-in-article">
<span class="language">
<a href="https://blog.schawe.me/en/git-subtree.html"><i class="fa fa-globe"></i> en</a>
</span>
</span>
<span class="category category-snip">
<a href="https://blog.schawe.me/categories.html#snip-ref">Snip</a>
</span>
</div>
</header>
<div class="post-content">
<p>Wir alle kennen die Situation: Eine neue Idee, mit der wir unser bestehendes Projekt mit dem Namen <code>alt</code> erweitern, sodass wir sogleich im zugehörigen Repository ein Unterverzeichnis <code>neueIdee</code> anlegen. Die Idee stellt sich dann als so gut heraus, dass sie auch außerhalb des Projektes <code>alt</code> nützlich wäre. Es wäre also sehr sinnvoll ein neues Repository <code>neu</code> anzulegen, das nur den Inhalt des Unterverzeichnisses <code>neueIdee</code> enthalten soll. Tatsächlich scheint dieses Problem wohl so oft vorzukommen, dass es seit 2012 ein extra git Subcommand für diesen Zweck (und etwas kompliziertere Fälle) gibt: <code>git subtree</code></p>
<h2>Neues Repository aus einem Unterverzeichnis</h2>
<div class="highlight"><pre><span></span><code>alt/
├─ neueIdee/
│  ├─ lib.rs
├─ main.rs
</code></pre></div>
<p>Wir wechseln also in das Repository <code>alt</code> führen dort folgendes Kommando aus:</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>subtree<span class="w"> </span>split<span class="w"> </span>--prefix<span class="o">=</span>neueIdee/<span class="w"> </span>--branch<span class="o">=</span>nurNeueIdeeBranch
</code></pre></div>
<p>Dies erzeugt in diesem Repository zunächst einen neuen Branch <code>nurNeueIdeeBranch</code>, der nur den Inhalt von <code>neueIdee</code> hat — also ein anderes Wurzelverzeichnis. Dieser Branch enthält also eine neu geschriebene History, die nur aus Commits besteht, die (auch) Einfluss auf Dateien unterhalb von <code>neueIdee</code> hatten.</p>
<p>Nun können wir unser neues Repository <code>neu</code> anlegen und den soeben erzeugten Branch pullen.</p>
<div class="highlight"><pre><span></span><code><span class="nb">cd</span><span class="w"> </span>..<span class="w"> </span><span class="p">;</span><span class="w"> </span>mkdir<span class="w"> </span>neu<span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>neu
git<span class="w"> </span>init
git<span class="w"> </span>pull<span class="w"> </span>../alt<span class="w"> </span>nurNeueIdeeBranch
</code></pre></div>
<p>Und schon haben wir ein neues Repository, das nur den gewünschten Inhalt hat.</p>
<div class="highlight"><pre><span></span><code>alt/
├─ main.rs
neu/
├─ lib.rs
</code></pre></div>
<p>Möglicherweise wollen wir noch einen Commit im alten Repository tätigen, der das <code>neueIdee</code> Unterverzeichnis löscht. Möglicherweise müssen wir im neuen Repository noch Änderungen am Infrastrukturcode vornehmen.</p>
<h2>Verschieben eines Unterverzeichnisses in ein bestehendes Repository</h2>
<p>Womöglich fällt uns aber auch auf, dass der Code besser in ein anderes Repository statt eines Neuen passt? Vielleicht weil wir gerade dabei sind unseren Code in einem Monorepo zu sammeln? Auch kein Problem!</p>
<div class="highlight"><pre><span></span><code>alt/
├─ neueIdee/
│  ├─ lib.rs
├─ main.rs
monorepo/
├─ project1/
├─ project2/
</code></pre></div>
<p>Wir haben oben  bereits den <code>nurNeueIdeeBranch</code> erstellt, den wir nun in das Unterverzeichnis <code>guteIdee</code>des Repositorys <code>monorepo</code> einfügen wollen. Auch hier hilft uns wieder <code>git subtree</code> weiter:</p>
<div class="highlight"><pre><span></span><code><span class="nb">cd</span><span class="w"> </span>monorepo
git<span class="w"> </span>branch<span class="w"> </span>mitGuterIdeeBranch
git<span class="w"> </span>checkout<span class="w"> </span>mitGuterIdeeBranch
git<span class="w"> </span>subtree<span class="w"> </span>add<span class="w"> </span>--prefix<span class="o">=</span>guteIdee/<span class="w"> </span>../alt<span class="w"> </span>nurNeueIdeeBranch
</code></pre></div>
<p>Sobald wir uns in dem neuen Branch <code>mitGuterIdeeBranch</code> überzeugt haben, dass alles zu unserer Zufriedenheit geklappt hat und wir möglicherweise noch Infrastrukturcode angepasst haben, können wir den Branch nach <code>main</code> mergen und sind fertig.</p>
<div class="highlight"><pre><span></span><code>alt/
├─ neueIdee/
│  ├─ lib.rs
├─ main.rs
monorepo/
├─ project1/
├─ project2/
├─ guteIdee/
│  ├─ lib.rs
</code></pre></div>
</div>
</article>
<article class="post">
<header>
<h2 class="post-title">
<a href="https://blog.schawe.me/paper-convex-highdim.html"> Convex hulls of random walks in higher dimensions: A large deviation study  </a>
</h2>
<div class="post-meta">
<div>
<span class="doi-details">
                        Hendrik Schawe, Alexander K. Hartmann, Satya N. Majumdar,
                        Physical Review E <b>96</b>, 062101 (2017)
                    </span>
</div>
<time class="post-time" datetime="2022-05-28T16:08:00+02:00">28.05.2022</time>
<span class="category category-phys">
<a href="https://blog.schawe.me/categories.html#phys-ref">Phys</a>
</span>
<span class="tags-in-article">
<span class="tag">
<a href="https://blog.schawe.me/tags.html#bild-ref">Bild</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#physik-ref">Physik</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#veroffentlichung-ref">Veröffentlichung</a>
</span>
</span>
<span class="doi"><a href="https://dx.doi.org/10.1103/PhysRevE.96.062101">doi:10.1103/PhysRevE.96.062101</a></span>
</div>
</header>
<div class="post-content">
<p>Die Frage wie groß das Revier eines Tieres ist, ist in konkreten Fällen für Biologen
interessant und dank <span class="caps">GPS</span>-Sendern kann man es heutzutage sogar empirisch untersuchen. Aus der
Punktwolke der besuchten Orte kann man eine Fläche abschätzen — im einfachsten Fall
indem man die konvexe Hülle um alle besuchten Orte zeichnet.</p>
<p>Als Physiker sind mir echte Tiere zu kompliziert, sodass ich stattdessen annehme,
dass sie punktförmig sind und ihre Bewegung ein <em>Random Walk</em> in einer isotropen
Umgebung ist. Also springen meine idealisierten Tiere unabhängig von ihren bisherigen
Handlungen zu ihrem nächsten Aufenthaltsort — der Abstand vom aktuellen Punkt ist dabei
in jeder Dimension unabhängig und normalverteilt.</p>
<p><em>In jeder Dimension?</em> Ja, genau! Wir wollen schließlich auch das Revierverhalten von
vierdimensionalen Space Whales untersuchen.</p>
<p><img alt="Ein vierdimensionaler Weltraumwal, oder was Stable Diffusion sich darunter vorstellt" height="512" src="/img/SpaceWhale.webp" width="512"/></p>
<p>Spaß beiseite, in dieser Veröffentlichung geht es natürlich eher um fundamentale
Eigenschaften von Random Walks — einer der einfachsten und deshalb am besten
untersuchten Markow-Prozesse. Und zwar im Hinblick auf Large Deviations,
die extrem unwahrscheinlichen Ereignisse, die weit jenseits der Möglichkeiten
von konventionellen Sampling-Methoden liegen. Details hierzu sind am besten
direkt im <a href="https://academic.schawe.me/pdf/2017_convex_highdim_PRE.pdf">Artikel</a> oder mit einer
Menge Hintergrundinformationen und ausführlicher als für ein Blog angemessen
in dem entsprechenden Kapitel und Anhang meiner <a href="https://academic.schawe.me/pdf/dissertation.pdf">Dissertation</a>
nachzulesen. Insbesondere ist dort auch beschrieben wie die geometrischen
Unterprobleme effizient gelöst werden können, auf die wir im Verlauf dieses
Blogposts stoßen werden.</p>
<p>Das Problem eine konvexe Hülle zu finden ist einerseits einfach zu begreifen,
schön geometrisch und sehr gut untersucht. Dadurch sind überraschend viele
Algorithmen bekannt, die unterschiedliche Vor- und Nachteile haben.</p>
<p>Im Folgenden möchte ich deshalb ein paar Methoden vorstellen, wie man effizient
die konvexe Hülle einer Punktmenge bestimmen kann, und dies mit animierten gifs von
Punkten und Strichen visualisieren. Der Code zur Erstellung der Visualisierungen
ist übrigens in Rust geschrieben und auf <a href="https://github.com/surt91/convex_hulls">GitHub</a> zu finden.</p>
<h2>Andrew’s Monotone Chain</h2>
<p>In zwei Dimensionen kann man ausnutzen, dass die konvexe Hülle ein Polygon ist, das
man durch die Reihenfolge der Eckpunkte definieren kann. Die grundlegende Idee ist
also die Punkte im Uhrzeigersinn zu sortieren, in dieser Reihenfolge, mit dem
Punkt ganz links startend, alle zu einem Polygon hinzuzufügen und dabei darauf
zu achten, dass die drei neusten Punkte des Polygons ein negativ orientiertes Dreieck
bilden, also dass sie im „Uhrzeigersinn drehen“. Wenn das nicht der Fall ist,
wird der mittlere Punkt entfernt.</p>
<p><img alt="Sechs Schritte von Andrew's Monotone Chain -- oder Graham Scan" class="invertable" height="1170" src="/img/ch_andrew_steps.webp" width="3440"/></p>
<p>Dies ist übrigens die ursprüngliche Variante, der <em>Graham Scan</em>. Andrew verbesserte
diesen Algorithmus dadurch, dass nicht im Uhrzeigersinn sortiert werden muss, sondern
man lexikographisch nach horizontaler Koordinate (bei Gleichstand entscheidet die
vertikale Koordinate) sortiert. Dann bildet dieser Algorithmus die obere Hälfte der Hülle
und wenn man ihn rückwärts auf die sortierten Punkte anwendet, die untere Hälfte.</p>
<p><img alt="Andrew's Monotone Chain" class="invertable" height="800" src="/img/ch_andrew.gif" width="800"/></p>
<p>Die Komplexität für <span class="math">\(n\)</span> Punkte ist somit <span class="math">\(\mathcal{O}(n \ln n)\)</span> limitiert durch das Sortieren.</p>
<h2>Jarvis March: Gift Wrapping</h2>
<p>Ein Geschenk einzupacken ist ein relativ intuitiver Prozess: Wir bewegen das Papier
so lange herunter, bis wir auf einen Punkt des Geschenkes treffen, wo es hängen bleibt
Dann wickeln wir weiter, bis wir auf den nächsten Punkt stoßen. Dabei streben wir an die
konvexe Hülle zu finden, denn sie ist das Optimum möglichst wenig Papier zu verbrauchen
während wir die Punktwolke einhüllen, die wir verschenken wollen. Und offenbar klappt das
auch in drei Dimensionen!</p>
<p>In einem Computer ist es allerdings einfacher das Geschenkpapier von innen aus der Punktwolke
heraus nach außen zu falten. Für jede Facette testen wir also jeden der <span class="math">\(n\)</span> Punkte in der
Punktwolke darauf, ob er links von unserem Stück Geschenkpapier liegt. Wenn ja, falten wir das
Papier weiter. Sobald wir alle <span class="math">\(n\)</span> Punkte ausprobiert haben, wissen wir, dass das Geschenkpapier
an der richtigen Stelle liegt, sodass anfangen können die nächste Facette mit dem Geschenkpapier
zu bilden indem wir von innen alle Punkte durchtesten.</p>
<p><img alt="Jarvis March: Gift Wrapping" class="invertable" height="800" src="/img/ch_jarvis.gif" width="800"/></p>
<p>Interessanterweise müssen wir also für jeden der <span class="math">\(h\)</span> Punkte, die zur Hülle gehören <span class="math">\(\mathcal{O}(n)\)</span> Punkte
prüfen, sodass die Komplexität abhängig ist vom Ergebnis: <span class="math">\(\mathcal{O}(n h)\)</span></p>
<h2>Chan’s Algorithm</h2>
<p>Wir haben also einen <span class="math">\(\mathcal{O}(n \ln n)\)</span> und einen <span class="math">\(\mathcal{O}(n h)\)</span> Algorithmus kennen gelernt,
aber können wir noch besser werden? Ja! <span class="math">\(\mathcal{O}(n \ln h)\)</span> ist die theoretische untere Komplexitätsgrenze
für 2D konvexe Hüllen. Beispielsweise Chans Algorithmus erreicht diese Komplexität mit einem trickreichen
zweistufigen Prozess.</p>
<p>Zuerst teilt man die Punktwolke in zufällige Untermengen mit jeweils etwa <span class="math">\(m\)</span> Punkten ein. Für jede berechnet
man die konvexe Hülle, bspw. mit Andrews Algorithmus. Dann benutzt man Jarvis March, um die Hülle zu konstruieren,
dabei muss man allerdings nicht mehr alle Punkte durchprobieren, sondern nur noch die Tangenten, die in der Animation
mit grünen Strichen gekennzeichnet sind. Die Tangenten kann man für jede der <span class="math">\(k = \lceil \frac{n}{m} \rceil\)</span> Sub-Hüllen
effizient in <span class="math">\(\mathcal{O}(m)\)</span> bestimmen. Dazu benutzt man einem Algorithmus, der an eine Binärsuche erinnert.
Zusammen hat dies also eine Komplexität von <span class="math">\(\mathcal{O}((n+kh) \ln m)\)</span>.</p>
<p>Aber ich hatte <span class="math">\(\mathcal{O}(n \ln h)\)</span> versprochen. Nun, um das zu erreichen, müssen wir einfach nur <span class="math">\(m \approx h\)</span> wählen.
Aber wie kommen wir an <span class="math">\(h\)</span> bevor wir die Hülle berechnet haben? Der Trick ist, mit einem niedrigen <span class="math">\(m\)</span> zu starten,
dann nur <span class="math">\(m\)</span> Schritte des Jarvis-Teils des Algorithmus durchzuführen und wenn die Hülle dann noch nicht fertig ist
<span class="math">\(m\)</span> zu erhöhen und es wieder von vorne zu beginnen. Damit dieser iterative Teil des Algorithmus nicht unsere Komplexität
erhöht, muss <span class="math">\(m\)</span> schnell genug wachsen, was in der Regel durch Quadrieren des alten Werten erreicht wird.</p>
<p><img alt="Chan's Algorithm" class="invertable" height="800" src="/img/ch_chan.gif" width="800"/></p>
<h2>QuickHull</h2>
<p>Zuletzt möchte ich hier noch QuickHull vorstellen, weil dieser Algorithmus meiner Meinung nach einen sehr hübschen
rekursiven <em>divide and conquer</em> Ansatz verfolgt — ein bisschen wie QuickSort.
In zwei Dimensionen starten wir mit dem Punkt ganz links <span class="math">\(A\)</span> und ganz rechts <span class="math">\(B\)</span>. Dann finden wir den Punkt <span class="math">\(C\)</span> der
am weitesten entfernt ist von der Strecke <span class="math">\(\overline{AB}\)</span> und links von der Strecke ist. Diesen Schritt wiederholen wir
rekursiv auf den Strecken <span class="math">\(\overline{AC}\)</span> und <span class="math">\(\overline{CB}\)</span> (und <span class="math">\(\overline{BA}\)</span> für die untere Hälfte.)</p>
<p><img alt="QuickHull" class="invertable" height="800" src="/img/ch_quickhull.gif" width="800"/></p>
<h2>Mehr Dimensionen</h2>
<p>Aber ich hatte Space Whales versprochen, also können wir uns nicht mit 2D zufrieden geben!
Tatsächlich müssen wir schon beim Verallgemeinern auf 3D aufpassen. Schließlich konnten
wir für 2D die konvexe Hülle als Sequenz von Punkten repräsentieren. Für höhere Dimensionen
müssen wir sie allerdings als Menge von Facetten repräsentieren. Glücklicherweise tauchen
für noch höhere Dimensionen dann keine weiteren Schwierigkeiten mehr auf — abgesehen von der
Grundsätzlichen Schwierigkeit, dass höherdimensionale Gebilde deutlich größere Oberflächen
haben und somit die konvexe Hülle aus deutlich mehr Facetten besteht, sodass die untere Schranke
für die Komplexität für Dimension <span class="math">\(d\)</span> durch <span class="math">\(\mathcal{O}(n^{\lfloor d / 2 \rfloor})\)</span> gegeben ist.</p>
<p>Bevor ich hier QuickHull für <span class="math">\(d=3\)</span> beschreibe, möchte ich darauf hinweisen, dass es die
<a href="http://www.qhull.org/"><code>qhull</code> Implementierung</a> gibt, die sich bspw. auch um die subtilen numerischen
Fehler kümmert, die sich bei sehr spitzen Winkeln einschleichen können.</p>
<p>Grundsätzlich bleibt das Vorgehen gleich: Wir starten mit einem <span class="math">\(d\)</span>-dimensionalen Simplex, also für <span class="math">\(d=3\)</span>
mit einem Tetraeder, dessen Eckpunkte zur konvexen Hülle gehören. Dann führen wir für jede Facette
den rekursiven Schritt durch: Finde den Punkt, der am weitesten <em>vor</em> der Facette (also außerhalb des Tetraeders) ist.
Diesen Punkt nennt man <em>Eye-Point</em>. Denn es reicht jetzt im Gegensatz zum 2D Fall nicht mehr
einfach neue Facetten aus den Rändern und dem neuen Punkt zu bilden. Stattdessen müssen wir alle
Facetten, deren Vorderseite (also Außenseite) wir vom Eye-Point aus sehen können entfernen und
neue Facetten mit dem Horizont und dem <em>Eye-Point</em> bilden. In der Animation unten sind der <em>Eye-Point</em>
sowie die Facetten, die er sieht, rot dargestellt. Der Horizont ist mit schwarzen Strichen gekennzeichnet.</p>
<p>Wird dieser Schritt rekursiv auf alle neu hinzugefügten Facetten angewendet, resultiert die
konvexe Hülle. Und genauso, wenn auch deutlich schwieriger darstellbar, funktioniert es auch
für alle höheren Dimensionen.</p>
<p><img alt="QuickHull" height="1450" src="/img/ch_quickhull3d.gif" width="1450"/></p>
<p>Eine wichtige Anwendung für 3D konvexe Hüllen ist übrigens die Delaunay-Triangulation einer planaren
Punktmenge. Die wiederum kann für eine effiziente Berechnung des <a href="https://blog.schawe.me/relative-neighborhood-graph.html">Relative-Neighborhood-Graphs aus
diesem Post</a> genutzt werden.</p>
</div>
</article>
<article class="post">
<header>
<h2 class="post-title">
<a href="https://blog.schawe.me/perfect-snake.html"> Perfect Snake  </a>
</h2>
<div class="post-meta">
<time class="post-time" datetime="2022-05-21T11:03:00+02:00">21.05.2022</time>
<span class="languages-in-article">
<span class="language">
<a href="https://blog.schawe.me/en/perfect-snake.html"><i class="fa fa-globe"></i> en</a>
</span>
</span>
<span class="category category-code">
<a href="https://blog.schawe.me/categories.html#code-ref">Code</a>
</span>
<span class="tags-in-article">
<span class="tag">
<a href="https://blog.schawe.me/tags.html#game-ref">Game</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#github-ref">GitHub</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#java-ref">Java</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#javascript-ref">JavaScript</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#neural-networks-ref">Neural Networks</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#python-ref">Python</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#snake-ref">Snake</a>
</span>
</span>
</div>
</header>
<div class="post-content">
<p>Ich habe auf diesem Blog schon über eine Reihe von Snake Clonen [<a href="https://blog.schawe.me/snake.html">1</a>, <a href="https://blog.schawe.me/msnake.html">2</a>, <a href="https://blog.schawe.me/jsnake.html">3</a>, <a href="https://blog.schawe.me/restfulsnake.html">4</a>, <a href="https://blog.schawe.me/multijsnake.html">5</a>] geschrieben, die zum Teil auch Autopilot-Strategien hatten [<a href="https://blog.schawe.me/pysnake.html">6</a>, <a href="https://blog.schawe.me/rsnake.html">7</a>].
Die Autopiloten waren zwar meist interessant anzusehen — vor allem bei hohen Geschwindigkeiten — aber bei weitem nicht perfekt.</p>
<p>Auch wenn der Titel etwas zu viel verspricht, schafft es dieser Autopilot (zumindest manchmal) perfekte Spiele zu spielen.</p>
<p><img alt="Eine perfekte Partie Snake" height="200" src="/img/perfectsnake.gif" width="200"/></p>
<p>Und falls dieses gif nicht überzeugt, kann man den Autopiloten online
— dank TensorFlow.js — direkt im Browser ausprobieren auf <a href="https://snake.schawe.me/">snake.schawe.me</a>.</p>
<p>Aber was steckt dahinter?</p>
<h2>Neuronale Netze</h2>
<p>Wenn man nicht clever genug ist, eine direkte Lösung für ein Problem zu finden, kann man
versuchen ein neuronales Netz auf die Lösung des Problems zu trainieren. Vor einigen Jahren
hat ein <a href="https://arxiv.org/abs/1312.5602">Artikel</a>, in dem ein neuronales Netz trainiert
wurde alte Atari-Spiele zu spielen, für mediale Aufmerksamkeit gesorgt. Und die gleiche
Idee des <em>Reinforcement Learning</em> werde ich hier (nicht als erster
[<a href="https://github.com/pawel-kieliszczyk/snake-reinforcement-learning">8</a>,
<a href="https://towardsdatascience.com/learning-to-play-snake-at-1-million-fps-4aae8d36d2f1">9</a>])
auf Snake anwenden.</p>
<p>Die grundlegende Idee von Reinforcement Learning ist relativ einsichtig: Wir belohnen
das Modell für gute Entscheidungen, sodass es lernt mehr gute Entscheidungen zu treffen.
In unserem Fall werden gute Entscheidungen dadurch definiert, dass sie zu einer
hohen Punktzahl, also Länge der Schlange am Spielende, führen.</p>
<p>Glücklicherweise können wir auf die Literatur zurückgreifen, wie wir diese grundsätzliche
Idee umsetzen können. Das Modell, für das ich mich entschieden habe, ist ein Actor-Critic
Ansatz. Dabei nutze ich ein neuronales Netz, das als Input den aktuellen Zustand des
Spielfeldes bekommt — wie genau dieser Zustand aussieht, diskutieren wir weiter unten.
Dann geht es durch ein paar Schichten und endet in zwei „Köpfen“. Einer ist der <em>Actor</em>,
mit drei Output-Neuronen, die für „nach links“, „nach rechts“ und „geradeaus weiter“ stehen.
Der andere ist der <em>Critic</em>, der ein Output-Neuron hat, das abschätzt wie lang die
Schlange, ausgehend von der aktuellen Situation, noch werden kann — also wie gut die aktuelle
Situation ist.</p>
<p>Das Training läuft dann so ab, dass ein ganzes Spiel gespielt wird, folgend den Vorschlägen
des Actors mit etwas rauschen, um neue Strategien zu erkunden. Sobald es beendet ist, weil
die Schlange sich oder eine Wand gebissen hat, wird
der Critic mit allen Zuständen des Spielverlaufs darauf trainiert, Schätzungen
abzugeben, die möglichst gut zu der tatsächlich erreichten Länge am Spielende passen.
Außerdem wird der Actor darauf trainiert gute Entscheidungen zu treffen, indem zu den
Zuständen des Spielverlaufs andere Entscheidungen getroffen werden und die Bewertung
des Critic der resultierenden Situationen als Qualität der Entscheidung genutzt wird.
Actor und Critic helfen sich also gegenseitig besser zu werden.
Der gemeinsame Teil des neuronalen Netzes sollte im Idealfall nach genügend gespielten
Spielen dabei ein „Verständnis“ für Snake entwickeln. Genial!</p>
<h2>Technische Nebensächlichkeiten</h2>
<p>Meine Implementierung benutzt die Python Bibliotheken Keras und Tensorflow zum Training
und <a href="https://blog.schawe.me/multijsnake.html">multiJSnake</a> als <em>Environment</em>. Wir steuern also einen
Java-Prozess, um unser neuronales Netz in Python zu trainieren.
Diese Entscheidung ist etwas unorthodox, aber bot Potential für einen Blogpost auf dem
<a href="https://blog.codecentric.de/2021/11/java-klassen-python/">Blog meines Arbeitgebers</a>.</p>
<p>Wir können das Environment getrost als Black-Box betrachten, die dafür sorgt, dass die Regeln
von Snake befolgt werden.</p>
<h2>Lokale Informationen</h2>
<p>Eine der wichtigsten Entscheidungen ist nun, wie der Input in das Modell aussieht.
Die einfachste Variante, die sich auch gut zum Testen eignet, ist die lokale
Information rund um den Kopf der Schlange: Drei Neuronen, die jeweils 1 oder 0 sind,
wenn das Feld links, rechts und geradeaus vom Kopf belegt sind (und acht weitere für
etwas mehr Weitsicht auf die Diagonalen und übernächste Felder vorne, rechts, links und
diesmal auch zurück). Damit die Schlange
auch das Futter finden kann, fügen wir noch 4 weitere Neuronen hinzu, die per 1 oder 0
anzeigen, ob das Futter in, rechts, links oder entgegengesetzt der Bewegungsrichtung
der Schlange ist.</p>
<p>Mit diesem Input füttern wir eine einzelne vollvernetzte Schicht, hinter der wir
direkt die Actor und Critic Köpfe anschließen.</p>
<p><img alt="Layout des neuronalen Netzes mit lokaler Information (Visualisierung: netron)" class="invertable" src="/img/nn_local.svg"/></p>
<p>Das reicht aus, damit die Schlange nach ein paar tausend Trainingsspielen zielstrebig auf das Futter
zusteuert und sich selbst ausweicht. Allerdings reicht es noch nicht, um zu verhindern,
dass sie sich selbst in Schlaufen fängt. Da war der Autopilot von
<a href="https://blog.schawe.me/rsnake.html">rsnake</a> besser.</p>
<p><img alt="Ein paar Spiele mit lokaler Information" height="200" src="/img/nn_local_game.gif" width="200"/></p>
<h2>Globale Informationen</h2>
<p>Um der Schlange eine Chance zu geben zu erkennen, dass sie sich gerade selbst fängt,
sollte man ihr erlauben das ganze Spielfeld zu sehen — schließlich sehen menschliche
Spieler auch das ganze Spielfeld. Bei einem <span class="math">\(10 \times 10\)</span> Spielfeld haben wir also
schon mindestens 100 Input-Neuronen, sodass vollvernetzte Schichten zu sehr großen
Modellen führen würden. Stattdessen bietet es sich bei solchen zweidimensionalen
Daten an <a href="https://en.wikipedia.org/wiki/Convolutional_neural_network"><em>convolutional</em> neuronale Netze</a>
zu nutzen. Um es unserer Schlange etwas einfacher zu machen, werden wir unser Spielfeld
in drei Kanäle aufteilen:</p>
<ol>
<li>der Kopf: nur an der Position des Kopfes ist eine 1, der Rest ist 0</li>
<li>der Körper: die Positionen an denen sich der Körper befindet zeigen wie viele Zeitschritte der Körper noch an dieser Position sein wird</li>
<li>das Futter: nur an der Position des Futters ist eine 1, der Rest ist 0</li>
</ol>
<p><img alt="Was ein Mensch sieht und was wir unserem neuronalen Netz zeigen" height="200" src="/img/nn_snake_channels.png" width="830"/></p>
<p>Dies ist auch kein unfairer Vorteil, schließlich sehen menschliche Spieler das Bild auch
mit drei Farbkanälen.</p>
<p>Und damit die Schlange nicht auch noch lernen muss was rechts und links bedeutet,
geben wir dem Actor 4 Outputs, die für Norden, Osten, Süden und Westen stehen.</p>
<p><img alt="Layout des Convolutional-Neural-Networks (Visualisierung: netron)" class="invertable" src="/img/nn_global.svg"/></p>
<p>Dieses Modell-Layout verdient es dann schon eher als <em>Deep Learning</em> bezeichnet zu werden.
Weitere Modell-Parameter, können auf <a href="https://github.com/surt91/multiJSnake">github.com/surt91/multiJSnake</a>
nachgeschlagen werden.</p>
<p>Nach einigen zehntausend Trainingsspielen funktioniert dieses Modell dann
tatsächlich gut genug, um regelmäßig perfekte Spiele auf einem
<span class="math">\(10 \times 10\)</span> Spielfeld zu erreichen. Aber da ich es nur auf  <span class="math">\(10 \times 10\)</span>
Feldern trainiert habe, versagt es leider auf jeder anderen Größe.</p>
</div>
</article>
</div>
<div class="post-navigation">
<nav class="pagination">
<a href="https://blog.schawe.me/index2.html">← Neuer</a>
<span class="separatordot">·</span>
<a href="https://blog.schawe.me/index4.html">Älter →</a>
<br/>
            3 / 23
        </nav>
</div>
</div>
<div id="last-update">
<time datetime="2024-12-27 10:29:03">10:29:03 27.12.2024</time>
</div>
</div>
<script async="" src="/theme/webassets-external/0cf7968c252ead5c096e55c1f7673096_rythm.js"></script>
<script async="" src="/theme/webassets-external/a8b690a4c23c0610ea6538a9352534be_totally_serious_script.js"></script>
<script async="" src="/theme/js/unregister_service_worker.js"></script>
</body>
</html>