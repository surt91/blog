<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>möchte­gern­geek - Code tag</title>
<meta content="Dinge, die ich für hübsch, praktisch oder interessant halte." name="description"/>
<meta content="Hendrik Schawe" name="author"/>
<meta content="Hendrik Schawe" name="copyright"/>
<meta content="#3d4f5d" name="theme-color"/>
<link href="/manifest.json" rel="manifest"/>
<link href="/favicon.ico" rel="icon" type="image/x-icon"/>
<!-- Add to home screen for Safari on iOS-->
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="default" name="apple-mobile-web-app-status-bar-style"/>
<meta content="möchtegerngeek" name="apple-mobile-web-app-title"/>
<link href="/extra/icons/icon-152x152.png" rel="apple-touch-icon"/>
<!-- Add to home screen for Windows-->
<meta content="/extra/icons/icon-152x152.png" name="msapplication-TileImage"/>
<meta content="#b0cadb" name="msapplication-TileColor"/>
<meta content="möchte­gern­geek" property="og:site_name"/>
<meta content="Hendrik Schawe" property="og:article:author"/>
<meta content="article" property="og:type"/>
<meta content="summary" name="twitter:card"/>
<meta content="https://blog.schawe.me/img/logo.png" property="og:image"/>
<meta content="https://blog.schawe.me/img/logo.png" name="twitter:image"/>
<link href="https://blog.schawe.me/tag/code2.html" hreflang="de" rel="alternate">
<link href="https://blog.schawe.me/en/tag/code2.html" hreflang="en" rel="alternate">
<link href="https://blog.schawe.me/tag/code2.html" hreflang="x-default" rel="alternate">
<link href="/theme/webassets-external/6fc8b5d0286641a8981481d8734adb14_pure-min.css" rel="stylesheet" type="text/css"/>
<link href="/theme/webassets-external/cd1fc9b8f4fd6935866873d6d3cfad1b_grids-responsive-min.css" rel="stylesheet" type="text/css"/>
<link href="/theme/css/blog.css" rel="stylesheet" type="text/css"/>
<script async="" src="/theme/js/mathjax-config.js"></script>
<script async="" crossorigin="anonymous" data-search-pseudo-elements="" integrity="sha512-RXf+QSDCUQs5uwRKaDoXt55jygZZm2V++WUZduaU/Ui/9EGp3f/2KZVahFZBKGH0s774sd3HmrhUy+SgOFQLVQ==" referrerpolicy="no-referrer" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/js/all.min.js"></script>
<!-- Preload the other fonts early -->
<link as="font" crossorigin="anonymous" href="/theme/woff2/Merriweather-12ptRegular.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/FiraSans-Regular.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/FiraSans-Bold.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/Merriweather-12ptItalic.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/firacode-regular.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/firacode-bold.woff2" rel="prefetch" type="font/woff2"/>
<link href="https://blog.schawe.me/feeds/all.atom.xml" rel="alternate" title="möchte­gern­geek - Full Atom Feed" type="application/atom+xml">
</link></link></link></link></head>
<body>
<div class="pure-g" id="layout">
<div class="sidebar pure-u-1 pure-u-lg-1-4">
<div class="header">
<h1 class="brand-title"><a href="https://blog.schawe.me">möchte­gern­geek</a></h1>
<nav class="nav">
<ul class="nav-list container">
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/en/"><i class="fa fa-globe"></i> en</a>
</li>
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/categories.html">Kategorien</a>
</li>
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/tags.html">Tags</a>
</li>
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/archives.html">Archiv</a>
</li>
</ul>
</nav>
<div class="container">
<a class="sidebar-social-links" href="https://hendrik.schawe.me" rel="noopener" target="_blank" title="Ich">
<i class="fas fa-user sidebar-social-links"></i>
</a>
<a class="sidebar-social-links" href="https://github.com/surt91" rel="noopener" target="_blank" title="GitHub">
<i class="fab fa-github sidebar-social-links"></i>
</a>
<a class="sidebar-social-links" href="mailto:hendrik.schawe+blog@gmail.com" rel="noopener" target="_blank" title="Email">
<i class="fas fa-envelope sidebar-social-links"></i>
</a>
<a class="sidebar-social-links" href="https://twitter.com/surt91" rel="noopener" target="_blank" title="Twitter">
<i class="fab fa-twitter sidebar-social-links"></i>
</a>
</div>
<div class="container">
<form action="https://blog.schawe.me/search.html" class="pure-form">
<fieldset>
<input aria-label="Suche" class="search-query" id="tipue_search_input" name="q" placeholder="Suche" type="text"/>
</fieldset>
</form>
</div>
</div>
</div>
<div class="content pure-u-1 pure-u-lg-3-4">
<div class="posts">
<article class="post">
<header>
<h2 class="post-title">
<a href="https://blog.schawe.me/twitter-background.html"> Twitter Profilhintergrundfarben  </a>
</h2>
<div class="post-meta">
<time class="post-time" datetime="2021-05-11T18:30:00+02:00">11.05.2021</time>
<span class="languages-in-article">
<span class="language">
<a href="https://blog.schawe.me/en/twitter-background.html"><i class="fa fa-globe"></i> en</a>
</span>
</span>
<span class="category category-code">
<a href="https://blog.schawe.me/categories.html#code-ref">Code</a>
</span>
<span class="tags-in-article">
<span class="tag">
<a href="https://blog.schawe.me/tags.html#bild-ref">Bild</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#code-ref">Code</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#python-ref">Python</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#twitter-ref">Twitter</a>
</span>
</span>
</div>
</header>
<div class="post-content">
<p>Für ein Projekt habe ich Tweets von &gt;8‘000‘000 Twitter-Usern eingesammelt.
Dabei fallen noch eine Reihe weiterer Daten an, wie die Profilhintergrundfarbe.
Es wäre eine Schande diese Daten einfach verkommen zu lassen, also habe ich
nach einer Möglichkeit gesucht diese Information ansprechend darzustellen,
was sich als weniger trivial herausgestellt hat, als ich ursprünglich angenommen
hatte: Im Idealfall sollten ähnliche Farben nahe beieinander liegen, allerdings
ist der <span class="caps">RGB</span> Farbraum ein dreidimensionaler Kubus, ein Bild aber nur zweidimensional,
sodass es keine
<a href="https://codegolf.stackexchange.com/q/22144">„richtige“ Art und Weise gibt, ähnliche Farben nebeneinander anzuordnen.</a></p>
<p>Ich habe mich hier dafür entschieden eine 2D <a href="https://de.wikipedia.org/wiki/Hilbert-Kurve">Hilbert-Kurve</a>
durch mein Bild zu legen und die Farben in der Reihenfolge zu zeichnen, in der
eine 3D Hilbert-Kurve ihnen im <span class="caps">RGB</span>-Kubus begegnet. Wenn man dann noch die beiden
Standardhintergrundfarben <code>#F5F8FA</code> und <code>#C0DEED</code> ignoriert, sieht das Ergebnis so aus.</p>
<p><a href="/img/twitter_background.png"><img alt="Twitter-Profil-Hintergrundfarbe" height="800" src="/img/twitter_background1200.webp" width="1200"/></a></p>
<p>Und dank der Python Pakete <code>hilbertcurve</code> und <code>pypng</code> ist der Code sogar ziemlich harmlos:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log2</span>

<span class="kn">from</span> <span class="nn">hilbertcurve.hilbertcurve</span> <span class="kn">import</span> <span class="n">HilbertCurve</span>
<span class="kn">import</span> <span class="nn">png</span>


<span class="sd">"""</span>
<span class="sd">    turn an RGB string like `#C0DEED` into a tuple of integers,</span>
<span class="sd">    i.e., coordinates of the RGB cube</span>
<span class="sd">"""</span>
<span class="k">def</span> <span class="nf">str2rgb</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">"#"</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="mi">16</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">],</span> <span class="mi">16</span><span class="p">))</span>


<span class="sd">"""</span>
<span class="sd">    `color_histogram` is a dict mapping an rgb string like `#F5F8FA`</span>
<span class="sd">    to the number of usages of this color</span>
<span class="sd">"""</span>
<span class="k">def</span> <span class="nf">plot_background_colors</span><span class="p">(</span><span class="n">color_histogram</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">"colors.png"</span><span class="p">):</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"F5F8FA"</span><span class="p">,</span> <span class="s2">"C0DEED"</span><span class="p">}</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">str2rgb</span><span class="p">(</span><span class="n">rgb</span><span class="p">):</span> <span class="n">d</span> <span class="k">for</span> <span class="n">rgb</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">color_histogram</span> <span class="k">if</span> <span class="n">rgb</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">}</span>

    <span class="c1"># calculate the size of the resulting image</span>
    <span class="c1"># for a 2D Hilbert curve, it mus be square with a width, which is a power of 2</span>
    <span class="n">num_pixels</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">min_width</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_pixels</span><span class="p">))</span>
    <span class="n">exponent</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="n">min_width</span><span class="p">))</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">exponent</span>

    <span class="c1"># output buffer for a width x width png, with 4 color values per pixel</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">width</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">)]</span>

    <span class="n">hc2</span> <span class="o">=</span> <span class="n">HilbertCurve</span><span class="p">(</span><span class="n">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># there are 256 = 2^8 values in each direction of the RGB cube</span>
    <span class="n">hc3</span> <span class="o">=</span> <span class="n">HilbertCurve</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="n">sorted_rgbs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hc3</span><span class="o">.</span><span class="n">distance_from_point</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">rgb</span> <span class="ow">in</span> <span class="n">sorted_rgbs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">rgb</span><span class="p">]):</span>
            <span class="c1"># get the coordinate of the next pixel</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">hc2</span><span class="o">.</span><span class="n">point_from_distance</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="c1"># assign the RGBA values to the pixel</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">4</span> <span class="o">*</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">4</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">4</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">4</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>

            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">png</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s1">'RGBA'</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</code></pre></div>
<p>Das Histogram, das als Input benötigt wird war in meinem Fall nur eine <span class="caps">SQL</span> Query entfernt:</p>
<div class="highlight"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="n">profile_background_color</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="n">profile_background_color</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span>
<span class="w">    </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">profile_background_color</span><span class="p">;</span>
</code></pre></div>
</div>
</article>
<article class="post">
<header>
<h2 class="post-title">
<a href="https://blog.schawe.me/pebble-rules.html"> Pebble Rules  </a>
</h2>
<div class="post-meta">
<time class="post-time" datetime="2017-12-10T15:57:00+01:00">10.12.2017</time>
<span class="category category-code">
<a href="https://blog.schawe.me/categories.html#code-ref">Code</a>
</span>
<span class="tags-in-article">
<span class="tag">
<a href="https://blog.schawe.me/tags.html#bild-ref">Bild</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#c-ref">C</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#code-ref">Code</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#github-ref">GitHub</a>
</span>
</span>
</div>
</header>
<div class="post-content">
<p>Im letzten Monat habe ich jemanden getroffen, auf dessen <a href="http://clisby.net/projects/pebble_app/">Armbanduhr eine <span class="caps">MCMC</span> Simulation von Hamilton-Pfaden</a>
auf einem quadratischen Gitter liefen. Ich war derartig begeistert, dass ich
beschlossen habe auch etwas auf meiner Pebble simulieren zu lassen. Aufgrund
der geringen Auflösung des Displays (<span class="math">\(144 \times 168\)</span>) bieten sich „blockige“
Visualisierungen an. Glücklicherweise habe ich schon genügend Spielereien
geschrieben, die sich eignen
[<a href="https://blog.schawe.me/labyrinthartiger-zellularer-automat.html">1</a>,
    <a href="https://blog.schawe.me/depth-first-search-und-labyrinthe.html">2</a>,
    <a href="https://blog.schawe.me/rule-90.html">3</a>,
    <a href="https://blog.schawe.me/conways-game-of-life.html">4</a>].</p>
<p>Pebble wurde zwar inzwischen von Fitbit aufgekauft, aber das <span class="caps">SDK</span> ist noch
verfügbar. Die neueren Exemplare lassen sich per JavaScript programmieren,
meine „Kickstarter Edition“ aus der ersten Generation allerdings noch nicht.</p>
<p>Da ich meine Uhr also in C programmieren muss, konnte ich allerdings den
den alten Code aus <a href="https://blog.schawe.me/rule-90.html">Wolfram’s Rules</a> wiederbenutzen.</p>
<video autoplay="" class="fixed-size-800" controls="" height="1000" loop="" poster="/img/pebble-rules.jpg" width="800">
<source src="/vid/pebble-rules.mp4" type="video/mp4"/>
Your browser does not support the video tag.
</video>
<p>Der Code ist auf <a href="https://github.com/surt91/pebble-wolfram">GitHub</a> verfügbar.</p>
</div>
</article>
<article class="post">
<header>
<h2 class="post-title">
<a href="https://blog.schawe.me/randomFractals.html"> A Fractal A Day  </a>
</h2>
<div class="post-meta">
<time class="post-time" datetime="2017-11-29T10:47:00+01:00">29.11.2017</time>
<span class="category category-code">
<a href="https://blog.schawe.me/categories.html#code-ref">Code</a>
</span>
<span class="tags-in-article">
<span class="tag">
<a href="https://blog.schawe.me/tags.html#bild-ref">Bild</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#chaos-ref">Chaos</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#code-ref">Code</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#formel-ref">Formel</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#github-ref">GitHub</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#physik-ref">Physik</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#rust-ref">Rust</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#twitter-bot-ref">Twitter-Bot</a>
</span>
</span>
</div>
</header>
<div class="post-content">
<p>Vor einiger Zeit habe ich ein Programm geschrieben, das verschiedene Typen von
Fraktalen generiert. Da viele Methoden Fraktale zu generieren relativ einfach
zu parallelisieren sind und großen Bedarf an Rechenkraft haben, habe ich mich
entschieden es in Rust zu implementieren. Bei Interesse kann das
<a href="https://github.com/surt91/AFractalADay">Programm von Github bezogen</a> werden.</p>
<p>Da Fraktale nett anzuschauen sind, ist dieser Beitrag voller hochaufgelöster
Bilder. Damit diese Seite dennoch flüssig geladen wird — auch bei langsamen
Verbindungen, habe ich extra für diesen Eintrag in die
<a href="https://blog.schawe.me/image-preview.html">Technik dieses Blogs</a> eingegriffen.
Außerdem gibt es <a href="https://twitter.com/AFractalADay">@AFractalADay</a> auf
Twitter, der täglich ein zufälliges Fraktal tweetet.</p>
<h3>Escape Time</h3>
<p>Die erste Klasse von Fraktalen, die ich hier zeigen möchte, wird definiert durch
das Konvergenzverhalten des wiederholten Anwendens einer Funktion. Was genau
dieser Satz bedeutet, lässt sich am besten an einem Beispiel erklären.</p>
<h4>Mandelbrot-Menge</h4>
<p>Das vermutlich bekannteste Fraktal ist das Apfelmännchen, das die
Mandelbrotmenge visualisiert. Das ist die Menge der komplexen Zahlen
<span class="math">\(c = x + iy,\)</span> die nicht konvergieren, wenn die Funktion <span class="math">\(f_c(z) = z^2 + c\)</span>
wiederholt angewendet wird. Also wenn die Folge
</p>
<div class="math">$$f_c(0), f_c(f_c(0)), f_c(f_c(f_c(0))), ...$$</div>
<p>
gegen einen endlichen Wert strebt.</p>
<p>Wenn man jeden Punkt <span class="math">\(c\)</span> auf der komplexen Ebene entsprechend des Konvergenzverhaltens
bezüglich dieser Folge einfärbt — schwarz wenn es konvergiert, blau für langsame
Divergenz, rot für schnelle Divergenz — erhält man ein solches Bild:</p>
<p><a href="/img/mandelbrot.png"><img alt="Zoom auf das Apfelmännchen" height="600" src="/img/mandelbrot1200.webp" width="1200"/></a></p>
<p>Dies ist ein Zoom auf den Rand des Apfelmännchens. Tatsächlich ist die
Mandelbrotmenge kein Fraktal im eigentlichen Sinne, da seine fraktale Dimension
2 ist — der schwarze Bereich füllt eine Fläche.</p>
<p>Es einfach möglich dieses Fraktal zu rastern und dabei jeden Pixel parallel zu
berechnen. Eine naive Implementierung könnte wie folgt aussehen.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// convenient iterators</span>
<span class="cp">#[macro_use]</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">itertools</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">itertools</span>::<span class="n">Itertools</span><span class="p">;</span>

<span class="c1">// parallelism</span>
<span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">rayon</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">rayon</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span>

<span class="c1">// complex numbers</span>
<span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">num</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">num</span>::<span class="n">complex</span>::<span class="n">Complex</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">raster</span><span class="p">(</span><span class="n">resolution</span>: <span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">))</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resolution</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// generate the points, we want to raster</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pixels</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iproduct</span><span class="o">!</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">x</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// start a parallel iterator on the points ...</span>
<span class="w">    </span><span class="n">pixels</span><span class="p">.</span><span class="n">par_iter</span><span class="p">()</span>
<span class="w">          </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|&amp;</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="c1">// ... mapping every point ...</span>
<span class="w">              </span><span class="kd">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_to_cplx_plane</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">              </span><span class="c1">// ... to the number of iterations needed to diverge</span>
<span class="w">              </span><span class="n">time_to_diverge</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="w">          </span><span class="p">})</span>
<span class="w">          </span><span class="p">.</span><span class="n">collect</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">map_to_cplx_plane</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Complex</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// TODO: here we need to get the offset and scale somehow</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_offset</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x_scale</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y_offset</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y_scale</span><span class="p">;</span>
<span class="w">    </span><span class="n">Complex</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">re</span>: <span class="nc">x</span><span class="p">,</span><span class="w"> </span><span class="n">im</span>: <span class="nc">y</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">time_to_diverge</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">state</span>: <span class="nc">Complex</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u64</span> <span class="p">{</span>
<span class="w">    </span><span class="c1">// threshold is 2^2, since we compare to the square of the norm</span>
<span class="w">    </span><span class="c1">// as soon as the norm is &gt;= 2 it is sure to diverge</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// abort after 1000 iterations</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">max_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ctr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="k">u64</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">        </span><span class="n">ctr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="n">state</span><span class="p">.</span><span class="n">norm_sqr</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">threshold</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ctr</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">max_count</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">ctr</span>
<span class="p">}</span>
</code></pre></div>
<h4>Julia-Mengen</h4>
<p>Nahe verwandt sind die Julia-Mengen. Hier benutzt man die gleiche Funktion <span class="math">\(f_c\)</span>,
allerdings färbt man jeden Punkt <span class="math">\(z\)</span> entsprechend seines Konvergenzverhaltens
bei einem festen Parameter <span class="math">\(c\)</span>.</p>
<p><a href="/img/julia.png"><img alt="Ein Julia-Fraktal" height="675" src="/img/julia1200.webp" width="1200"/></a></p>
<p>Tatsächlich ist jede beliebige Funktion <span class="math">\(f\)</span> erlaubt und nicht nur die oben erwähnte
quadratische. Mit unkonventioneller Zuordnung von Farben zu Divergenzzeiten
ergibt sich mit <span class="math">\(f(z) = (-2.6-i) \cosh(z)\)</span> dieses Bild:</p>
<p><a href="/img/julia2.png"><img alt="Ein weiteres Julia-Fraktal" height="600" src="/img/julia2_1200.webp" width="1200"/></a></p>
<h4>Newton-Fraktal</h4>
<p>Das <a href="https://de.wikipedia.org/wiki/Newton-Verfahren">Newton-Verfahren zur Findung von Nullstellen</a>
startet an einem beliebigen Punkt auf einer Kurve, und berechnet die Nullstelle
der Tangente an diesem Punkt. Mit der Tangente dieses Punktes wird genauso
verfahren. Dabei sollten sich die so erhaltenen Punkte immer dichter einer
Nullstelle nähern. Bei einer komplexen Funktion können wir dies für jeden
Startpunkt iterieren. Jeder Punkt wird gegen eine Nullstelle konvergieren, der
wir eine Farbe zuordnen und den Punkt mit dieser Farbe einfärben. Wenn wir die
Sättigung davon abhängig machen, wie schnell die Konvergenz ist, sieht das
Ergebnis für <span class="math">\(f(x) = z^4 + 5^{z+i} + 15\)</span> so aus.</p>
<p><a href="/img/newton.png"><img alt="Newton Fraktal für f(x) = z^4 + 5^{z+i} + 15" height="675" src="/img/newton1200.webp" width="1200"/></a></p>
<h3>Chaos Game</h3>
<p>Eine große Klasse von Fraktalen lässt sich mit dem Chaos Game erzeugen. Man
benutzt dazu mindestens zwei Abbildungen <span class="math">\(f_1(z)\)</span> und <span class="math">\(f_2(z)\)</span>, die jeweils einen
Punkt <span class="math">\(z\)</span> auf einen anderen Punkt abbilden. Man wählt einen Punkt zum Starten,
bildet ihn mit einer Zufälligen der beiden Abbildungen ab, zeichnet den
resultierenden Punkt ein und wiederholt dies sehr oft.</p>
<p>Dieser Algorithmus ist inherent sequenziell, allerdings kann man parallel an
vielen verschiedenen Punkten starten und die Ergebnisse dieser unabhängigen
Markovketten in einem Bild zusammenführen.</p>
<p>In Rust könnte der entsprechende Codeschnipsel so aussehen:</p>
<div class="highlight"><pre><span></span><code><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">num_cpus</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="n">mpsc</span>::<span class="n">channel</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="n">cpus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_cpus</span>::<span class="n">get</span><span class="p">();</span>

<span class="c1">// create a transmitter, receiver pair</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channel</span><span class="p">();</span>
<span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">cpus</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// clone a transmitter for each thread</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tx</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// generator yielding the points from the chaos game</span>
<span class="w">    </span><span class="c1">// using a random seed</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sampler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_sampler</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// we need some histogram implementation</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Histogram</span>::<span class="n">new</span><span class="p">();</span>

<span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// feed the samples into the histogram</span>
<span class="w">        </span><span class="n">hist</span><span class="p">.</span><span class="n">feed</span><span class="p">(</span><span class="n">sampler</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">iterations_per_task</span><span class="p">));</span>
<span class="w">        </span><span class="c1">// send the finished histogram to the receiver</span>
<span class="w">        </span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">hist</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>

<span class="c1">// collect all parallel computed histograms into main_hist</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">main_hist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Histogram</span>::<span class="n">new</span><span class="p">();</span>
<span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">cpus</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">recv</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="n">main_hist</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4>Sierpinski-Dreieck und Barnsley-Farn</h4>
<p>Mit dieser Methode kann man alte Bekannte wie das <a href="https://blog.schawe.me/rule-90.html">Sierpinski-Dreieck</a> erzeugen.</p>
<p><a href="/img/sierpinski.png"><img alt="Sierpinski-Dreieck" height="897" src="/img/sierpinski.png" width="1005"/></a></p>
<p>Dazu benötigt man die drei affinen Transformationen, die man alle mit gleicher
Wahrscheinlichkeit auswählt:
</p>
<div class="math">$$\begin{align}
f_1(\vec z) &amp;=\begin{pmatrix}
            -1/4         &amp; \sqrt 3 / 4 \\
            -\sqrt 3 / 4 &amp; -1/4
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            z_x \\
            z_y
        \end{pmatrix}
        +
        \begin{pmatrix}
                -1/4\\
                \sqrt 3 / 4
        \end{pmatrix}\\
f_2(\vec z) &amp;=\begin{pmatrix}
            1/2 &amp; 0 \\
            0   &amp; 1/2
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            z_x \\
            z_y
        \end{pmatrix}
        +
        \begin{pmatrix}
                1/4\\
                \sqrt 3 / 4
        \end{pmatrix}\\
f_3(\vec z) &amp;=\begin{pmatrix}
            -1/4 &amp; -\sqrt 3 / 4 \\
            \sqrt 3 / 4   &amp; 1/4
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            z_x \\
            z_y
        \end{pmatrix}
        +
        \begin{pmatrix}
                1\\
                0
        \end{pmatrix}
\end{align}$$</div>
<p>Ein anderes berühmtes Beispiel ist der Barnsley-Farn. Um ihn zu erzeugen, benutzt
man die folgenden vier affinen Abbildungen, die man mit den Wahrscheinlichkeiten
</p>
<div class="math">$$p_1 = 0.01, p_2 = 0.85, p_3 = 0.07, p_4 = 0.07$$</div>
<p>
verwendet:
</p>
<div class="math">$$\begin{align}
f_1(z) &amp;=\begin{pmatrix}
                0.16\\
                0
        \end{pmatrix}\\
f_2(z) &amp;=\begin{pmatrix}
            0.85 &amp; 0.04 \\
            0    &amp; -0.04
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            z_x \\
            z_y
        \end{pmatrix}
        +
        \begin{pmatrix}
                0.85\\
                1.6
        \end{pmatrix}\\
f_3(z) &amp;=\begin{pmatrix}
            0.2 &amp; -0.26 \\
            0   &amp; 0.23
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            z_x \\
            z_y
        \end{pmatrix}
        +
        \begin{pmatrix}
                0.22\\
                1.6
        \end{pmatrix}\\
f_4(z) &amp;=\begin{pmatrix}
            -0.15 &amp; 0.28 \\
            0     &amp; 0.26
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            z_x \\
            z_y
        \end{pmatrix}
        +
        \begin{pmatrix}
                0.24\\
                0.44
        \end{pmatrix}\\
\end{align}$$</div>
<p>Als Ergebnis erhält man diesen Farn.</p>
<p><a href="/img/fern.png"><img alt="Bernsley-Farn" height="1022" src="/img/fern.png" width="582"/></a></p>
<h4>Fractal Flame</h4>
<p><a href="http://flam3.com/flame_draves.pdf">Fractal Flame</a> ist der Name einer Klasse
von Zufallsfraktalen, die nach dem gleichen Muster wie oben aus einer Reihe
affiner Transformationen <span class="math">\(A_i\)</span> bestehen. Zusätzlich können die affinen
Transformationen mit einer nichtlinearen <em>Variation</em> <span class="math">\(V_j\)</span> erweitert werden,
sodass <span class="math">\(f_i(\vec z) = V_j(A_i(\vec z))\)</span> (oder Linearkombinationen dieser Variationen).
Zur Visualisierung werden die Punkte nicht direkt gezeichnet, sondern in ein
Histogramm eingetragen, aus dem die Farbintensitäten typischerweise
logarithmisch berechnet werden.</p>
<p><a href="/img/horseshoe.png"><img alt="Fractal Flame, 'Horseshoe' Variation" height="1022" src="/img/horseshoe1200.webp" width="1143"/></a></p>
<p>Hier wird jedem <span class="math">\(f_i\)</span> ein Farbton zugeordnet. Die Farbe eines Punktes ist eine
Mischung dieser Farben, die widerspiegelt, wie oft eine Abbildung genutzt wurde,
um an diesen Punkt zu gelangen.</p>
<p>Interessanterweise sind diese Systeme anscheinend sehr anfällig für schlechte
Zufallszahlen, was sich in „Löchern“ in den ansonsten glatten Flächen bemerkbar macht.</p>
<h4>Möbius Flame</h4>
<p>Diese Fraktale sind nahezu identisch zu den Fractal Flames, nur dass anstatt von
affinen Transformationen Möbius Transformationen auf der komplexen Ebene genutzt werden.</p>
<div class="math">$$f_i(z) = \frac{a_i z + b_i}{c_i z + d_i}$$</div>
<p><a href="/img/mobius.png"><img alt="Möbius Flame" height="599" src="/img/mobius1200.webp" width="1200"/></a></p>
<h4>Wie findet man „gute“ Parameter?</h4>
<p>Offenbar hat dieser Typ von Fraktal sehr viele freie Parameter. Um hübsche
Resultate zu generieren, müssen sie angepasst werden. Tatsächlich gibt es mit
<a href="https://electricsheep.org/">electric sheep</a> (ich hoffe stark, dass es eine
<a href="https://de.wikipedia.org/wiki/Tr%C3%A4umen_Androiden_von_elektrischen_Schafen%3F">Blade Runner</a>
Referenz ist) ein Crowdsourcing-Projekt,
das mithilfe von evolutionären Algorithmen und dem Feedback von Menschen
besonders ansehnliche Fraktale erzeugt.</p>
<p>Für mein Programm habe ich eine simplere Methode genutzt. Damit man ein Fraktal
gut sehen kann, sollte seine fraktale Dimension größer als 1 sein. Abschätzbar
ist es relativ einfach über die <a href="https://en.wikipedia.org/wiki/Correlation_dimension">Korrelations-Dimension</a>.
Dazu misst man die paarweisen Abstände von Punkten und misst den Exponenten ihrer
kumulativen Verteilungsfunktion.</p>
<p>Kombiniert mit einigen Heuristiken, die zu langgestreckte Fraktale verhindert,
sind die Ergebnisse meist ansprechend</p>
<h3>Weitere Fraktale</h3>
<p>Es gibt natürlich viel mehr Typen von Fraktalen. Auch wenn <a href="https://twitter.com/AFractalADay">@AFractalADay</a>
sie bisher nicht zeichnen kann, habe ich einige Bilder angefertigt, die ich
hier auch gerne zeigen möchte.</p>
<h4>Diffusionsbegrenztes Wachstum</h4>
<p>Diffusionsbegrenztes Wachstum bildet das Wachstum von Kristallen in stark
verdünnten Lösungen ab. Man startet mit einem Seed und lässt dann einzelne
Teilchen diffundieren, bis sie auf dem Nachbarfeld eines Seeds landen, wo sie
dann bleiben und Teil des Seeds werden. Dieser Prozess bildet verästelte
Strukturen aus.</p>
<p><a href="/img/dla_core.png"><img alt="Diffusionsbegrenztes Wachstum" height="1200" src="/img/dla_core1200.webp" width="1200"/></a></p>
<h4>Random Walks</h4>
<p>Einige Arten von Random Walks haben eine fraktale Dimension zwischen 1 und 2,
was sie zu ansehnlichen Fraktalen machen sollte. Der Smart Kinetic Self
Avoiding Walk, der in meinem <a href="https://blog.schawe.me/rsnake.html">rsnake</a> die Strategie des
Autopiloten ist, hat eine fraktale Dimension von <span class="math">\(\frac{7}{4}\)</span>. 100000 Schritte
sehen so aus:</p>
<p><a class="invertable" href="/img/sksaw.png"><img alt="Smart Kinetic Self Avoiding Walk, 100000 Schritte" height="1275" src="/img/sksaw1200.webp" width="1200"/></a></p>
</div>
</article>
</div>
<div class="post-navigation">
<nav class="pagination">
<a href="https://blog.schawe.me/tag/code.html">← Neuer</a>
<span class="separatordot">·</span>
<a href="https://blog.schawe.me/tag/code3.html">Älter →</a>
<br/>
            2 / 5
        </nav>
</div>
</div>
<div id="last-update">
<time datetime="2024-12-27 10:29:03">10:29:03 27.12.2024</time>
</div>
</div>
<script async="" src="/theme/webassets-external/0cf7968c252ead5c096e55c1f7673096_rythm.js"></script>
<script async="" src="/theme/webassets-external/a8b690a4c23c0610ea6538a9352534be_totally_serious_script.js"></script>
<script async="" src="/theme/js/unregister_service_worker.js"></script>
</body>
</html>