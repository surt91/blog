<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>möchte­gern­geek - Physik tag</title>
<meta content="Dinge, die ich für hübsch, praktisch oder interessant halte." name="description"/>
<meta content="Hendrik Schawe" name="author"/>
<meta content="Hendrik Schawe" name="copyright"/>
<meta content="#3d4f5d" name="theme-color"/>
<link href="/manifest.json" rel="manifest"/>
<link href="/favicon.ico" rel="icon" type="image/x-icon"/>
<!-- Add to home screen for Safari on iOS-->
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="default" name="apple-mobile-web-app-status-bar-style"/>
<meta content="möchtegerngeek" name="apple-mobile-web-app-title"/>
<link href="/extra/icons/icon-152x152.png" rel="apple-touch-icon"/>
<!-- Add to home screen for Windows-->
<meta content="/extra/icons/icon-152x152.png" name="msapplication-TileImage"/>
<meta content="#b0cadb" name="msapplication-TileColor"/>
<meta content="möchte­gern­geek" property="og:site_name"/>
<meta content="Hendrik Schawe" property="og:article:author"/>
<meta content="article" property="og:type"/>
<meta content="summary" name="twitter:card"/>
<meta content="https://blog.schawe.me/img/logo.png" property="og:image"/>
<meta content="https://blog.schawe.me/img/logo.png" name="twitter:image"/>
<link href="https://blog.schawe.me/tag/physik2.html" hreflang="de" rel="alternate">
<link href="https://blog.schawe.me/en/tag/physik2.html" hreflang="en" rel="alternate">
<link href="https://blog.schawe.me/tag/physik2.html" hreflang="x-default" rel="alternate">
<link href="/theme/webassets-external/6fc8b5d0286641a8981481d8734adb14_pure-min.css" rel="stylesheet" type="text/css"/>
<link href="/theme/webassets-external/cd1fc9b8f4fd6935866873d6d3cfad1b_grids-responsive-min.css" rel="stylesheet" type="text/css"/>
<link href="/theme/css/blog.css" rel="stylesheet" type="text/css"/>
<script async="" src="/theme/js/mathjax-config.js"></script>
<script async="" crossorigin="anonymous" data-search-pseudo-elements="" integrity="sha512-RXf+QSDCUQs5uwRKaDoXt55jygZZm2V++WUZduaU/Ui/9EGp3f/2KZVahFZBKGH0s774sd3HmrhUy+SgOFQLVQ==" referrerpolicy="no-referrer" src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/js/all.min.js"></script>
<!-- Preload the other fonts early -->
<link as="font" crossorigin="anonymous" href="/theme/woff2/Merriweather-12ptRegular.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/FiraSans-Regular.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/FiraSans-Bold.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/Merriweather-12ptItalic.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/firacode-regular.woff2" rel="prefetch" type="font/woff2"/>
<link as="font" crossorigin="anonymous" href="/theme/woff2/firacode-bold.woff2" rel="prefetch" type="font/woff2"/>
<link href="https://blog.schawe.me/feeds/all.atom.xml" rel="alternate" title="möchte­gern­geek - Full Atom Feed" type="application/atom+xml">
</link></link></link></link></head>
<body>
<div class="pure-g" id="layout">
<div class="sidebar pure-u-1 pure-u-lg-1-4">
<div class="header">
<h1 class="brand-title"><a href="https://blog.schawe.me">möchte­gern­geek</a></h1>
<nav class="nav">
<ul class="nav-list container">
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/en/"><i class="fa fa-globe"></i> en</a>
</li>
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/categories.html">Kategorien</a>
</li>
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/tags.html">Tags</a>
</li>
<li class="nav-item">
<a class="pure-button" href="https://blog.schawe.me/archives.html">Archiv</a>
</li>
</ul>
</nav>
<div class="container">
<a class="sidebar-social-links" href="https://hendrik.schawe.me" rel="noopener" target="_blank" title="Ich">
<i class="fas fa-user sidebar-social-links"></i>
</a>
<a class="sidebar-social-links" href="https://github.com/surt91" rel="noopener" target="_blank" title="GitHub">
<i class="fab fa-github sidebar-social-links"></i>
</a>
<a class="sidebar-social-links" href="mailto:hendrik.schawe+blog@gmail.com" rel="noopener" target="_blank" title="Email">
<i class="fas fa-envelope sidebar-social-links"></i>
</a>
<a class="sidebar-social-links" href="https://twitter.com/surt91" rel="noopener" target="_blank" title="Twitter">
<i class="fab fa-twitter sidebar-social-links"></i>
</a>
</div>
<div class="container">
<form action="https://blog.schawe.me/search.html" class="pure-form">
<fieldset>
<input aria-label="Suche" class="search-query" id="tipue_search_input" name="q" placeholder="Suche" type="text"/>
</fieldset>
</form>
</div>
</div>
</div>
<div class="content pure-u-1 pure-u-lg-3-4">
<div class="posts">
<article class="post">
<header>
<h2 class="post-title">
<a href="https://blog.schawe.me/paper-tsp-pt.html"> Phase Transitions of Traveling Salesperson Problems solved with Linear Programming and Cutting Planes  </a>
</h2>
<div class="post-meta">
<div>
<span class="doi-details">
                        Hendrik Schawe, Alexander K. Hartmann,
                        EPL (Europhysics Letters) <b>113</b>, 30004 (2016)
                    </span>
</div>
<time class="post-time" datetime="2018-07-31T06:28:00+02:00">31.07.2018</time>
<span class="languages-in-article">
<span class="language">
<a href="https://blog.schawe.me/en/paper-tsp-pt.html"><i class="fa fa-globe"></i> en</a>
</span>
</span>
<span class="category category-phys">
<a href="https://blog.schawe.me/categories.html#phys-ref">Phys</a>
</span>
<span class="tags-in-article">
<span class="tag">
<a href="https://blog.schawe.me/tags.html#physik-ref">Physik</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#veroffentlichung-ref">Veröffentlichung</a>
</span>
</span>
<span class="doi"><a href="https://dx.doi.org/10.1209/0295-5075/113/30004">doi:10.1209/0295-5075/113/30004</a></span>
</div>
</header>
<div class="post-content">
<p>In diesem Artikel wird ein Ensemble von Problemen des Handlungsreisenden (<span class="caps">TSP</span>)
eingeführt, das abhängig von einem Parameter $\sigma$ von einer trivial einfach
zu lösenden Konfiguration, nämlich Städte, die äquidistant auf einem Kreis angeordnet
sind, zum zufälligen euklidischen <span class="caps">TSP</span> in der Ebene interpoliert.</p>
<p><img alt="Einfach und schwierig zu lösende TSP Konfigurationen" class="invertable" height="1000" src="/img/tsp_interp.svg" width="3200"/></p>
<p>Danach werden mittels <a href="https://de.wikipedia.org/wiki/Lineare_Optimierung">linearer Programmierung</a> einige
Phasenübergänge festgestellt, ab welchen Werten von $\sigma$ das Problem
schwierig zu lösen wird. Zu zwei dieser Übergänge werden strukturelle
Eigenschaften der optimalen Lösung gefunden, die sich an dieser Stelle
ebenfalls charakteristisch ändern. Da die optimale Lösung nicht von der
Lösungsmethode abhängt, sind diese Phasenübergänge also nicht nur von Bedeutung
für das spezielle Lineare Programm bzw. den Algorithmus der zu dessen Lösung
genutzt wurde, sondern fundamentale Eigenschaft dieses <span class="caps">TSP</span> Ensembles.</p>
<p>Im Detail haben wir die klassische Formulierung von Dantzig genutzt:
\begin{align<em>}
    \label{eq:objective}
    &amp;\text{minimize}     <span class="amp">&amp;</span>  \sum_i \sum_{j&lt;i} c_{ij} x_{ij}\
    \label{eq:int}
    &amp;\text{subject to}   <span class="amp">&amp;</span>  x_{ij}                                &amp;\in {0,1}\ %\mathbb{Z}\
    \label{eq:inout}
    <span class="amp">&amp;</span> <span class="amp">&amp;</span>  \sum_{j} x_{ij}                       &amp;= 2&amp;            <span class="amp">&amp;</span> \forall i \in V \
    \label{eq:sec}
    <span class="amp">&amp;</span> <span class="amp">&amp;</span>  \sum_{i \in S, j \notin S} x_{ij}     &amp;\ge 2&amp;          <span class="amp">&amp;</span> \forall S \varsubsetneq V, S \ne \varnothing
\end{align</em>}</p>
<p>Hier ist $c_{ij}$ die Distanzmatrix zwischen allen Paaren von Städten aus $V$ und $x_{ij}$
die gesuchte Adjazenzmatrix, also $x_{ij} = 1$, wenn $i$ und $j$ aufeinanderfolgende Stationen
der Tour sind und $x_{ij} = 0$ sonst. Die erste Zeile minimiert also die Strecke der Tour.
Um zu vermeiden, dass wir die triviale Lösung $x_{ij}=0$, also „wenn wir zu Hause
bleiben müssen wir am wenigsten Strecke zurücklegen“ finden, zwingt die dritte
Zeile unseren Handlungsreisenden seine Tour so zu planen, dass in Summe zwei
Striche an jede Stadt gezeichnet werden — genug, um hinein und wieder hinaus
zu reisen. Allerdings, ist unser Handlungsreisender clever und würde versuchen uns
auszutricksen, indem er halbe Striche einzeichnen würde, wie
<a href="https://blog.schawe.me/tspview.html">in einem anderen Blogeintrag visualisiert</a>. Deshalb ist die
Bedingung in der zweiten Zeile nötig, die die Einträge in der Adjazenzmatrix auf
ganze Zahlen beschränkt. Dann bleibt nur noch das Problem, dass mehrere Routen,
die nicht verbunden sind erlaubt wären, sodass wir sie durch die letzte Zeile
verbieten: die <em>Subtour Elimination Constraints</em>. Der aufmerksame Leser mag
schon erkannt haben, dass es für jede Untermenge von Städten so eine Constraint
definiert, also exponentiell viele in der Anzahl der Städte. Die Lösung
zu dieses Problem liegt darin, dass nur sehr wenige wirklich gebraucht werden, sodass
man das Problem ohne diese Constraint löst, testet ob eine verletzt ist, was mittels
der Berechnung eines <a href="https://en.wikipedia.org/wiki/Minimum_cut">minimum cut</a> sehr
schnell geht und dann eine einzelne Constraint, die diese Konfiguration verbietet
hinzufügt. Diese Methode iterativ Constraints hinzuzufügen wird meist als <em>Cutting Planes</em> bezeichnet.</p>
<p>Also haben wir einen schnellen Algorithmus für das Problem des Handlungsreisenden
gefunden? Nein, leider können wir den <a href="https://en.wikipedia.org/wiki/Millennium_Prize_Problems#P_versus_NP">Millenium Preis</a> noch nicht beanspruchen. Es gibt keinen bekannten Algorithmus, der dieses Problem
unter Erfüllung der zweiten Zeilen, also Beschränkung auf ganzzahlige Lösungen lösen kann.
Aber sobald wir diese Bedingung fallen lassen, können wir klassische Verfahren der
linearen Programmierung nutzen, um dieses Problem effizient zu lösen. Dies wird auch
<a href="https://en.wikipedia.org/wiki/Linear_programming_relaxation">Relaxation</a> genannt. Die Länge der
Strecke ist immer eine untere Schranke für die tatsächliche Lösung. Und wenn unsere
Lösung per Zufall ganzzahlig ist, können wir uns sicher sein, die Optimale Lösung
gefunden zu haben.</p>
<p>Als Ordnungsparameter des Phasenübergangs zwischen leichten und schweren Konfigurationen
dient uns also die Wahrscheinlichkeit, dass
mittels eines Simplex-Solvers eine ganzzahlige, und damit optimale, Lösung
gefunden wird. Ohne die Subtour Elimination Constraints,
fällt der Phasenübergang auf den Punkt, an dem sich die optimale Lösung erstmals
von der Reihenfolge der Städte des ursprünglichen Kreises unterscheidet.
Mit den Subtour Elimination Constraints, fällt der Phasenübergang auf den
Punkt, wo die optimale Tour anfängt von einem Zickzack-Kurs auf große Meander zu
wechseln. Dies wird durch die geometrische Gewundenheit, die <em>Tortuosität</em>,
\begin{align<em>}
    \tau = \frac{n-1}{L} \sum_{i=1}^{n} \left( \frac{L_i}{S_i}-1 \right).
\end{align</em>}
ermittelt, die an diesem Punkt maximal wird. Hier wird die Tour in $N$
Teilstücke mit gleichem Vorzeichen der Krümmung unterteilt und für jedes
Teilstück das Verhältnis von direkter Ende-zu-Ende-Distanz $S_i$ zu der
Länge entlang der Tour $L-i$ summiert.</p>
<p>Wir haben also kontinuierliche Phasenübergänge in der Schwierigkeit dieses Problems
mittels linearer Programmierung detektiert und sie mit strukturellen Änderungen
des Verhaltens in Verbindung gebracht.</p>
</div>
</article>
<article class="post">
<header>
<h2 class="post-title">
<a href="https://blog.schawe.me/randomFractals.html"> A Fractal A Day  </a>
</h2>
<div class="post-meta">
<time class="post-time" datetime="2017-11-29T10:47:00+01:00">29.11.2017</time>
<span class="category category-code">
<a href="https://blog.schawe.me/categories.html#code-ref">Code</a>
</span>
<span class="tags-in-article">
<span class="tag">
<a href="https://blog.schawe.me/tags.html#bild-ref">Bild</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#chaos-ref">Chaos</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#code-ref">Code</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#formel-ref">Formel</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#github-ref">GitHub</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#physik-ref">Physik</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#rust-ref">Rust</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#twitter-bot-ref">Twitter-Bot</a>
</span>
</span>
</div>
</header>
<div class="post-content">
<p>Vor einiger Zeit habe ich ein Programm geschrieben, das verschiedene Typen von
Fraktalen generiert. Da viele Methoden Fraktale zu generieren relativ einfach
zu parallelisieren sind und großen Bedarf an Rechenkraft haben, habe ich mich
entschieden es in Rust zu implementieren. Bei Interesse kann das
<a href="https://github.com/surt91/AFractalADay">Programm von Github bezogen</a> werden.</p>
<p>Da Fraktale nett anzuschauen sind, ist dieser Beitrag voller hochaufgelöster
Bilder. Damit diese Seite dennoch flüssig geladen wird — auch bei langsamen
Verbindungen, habe ich extra für diesen Eintrag in die
<a href="https://blog.schawe.me/image-preview.html">Technik dieses Blogs</a> eingegriffen.
Außerdem gibt es <a href="https://twitter.com/AFractalADay">@AFractalADay</a> auf
Twitter, der täglich ein zufälliges Fraktal tweetet.</p>
<h3>Escape Time</h3>
<p>Die erste Klasse von Fraktalen, die ich hier zeigen möchte, wird definiert durch
das Konvergenzverhalten des wiederholten Anwendens einer Funktion. Was genau
dieser Satz bedeutet, lässt sich am besten an einem Beispiel erklären.</p>
<h4>Mandelbrot-Menge</h4>
<p>Das vermutlich bekannteste Fraktal ist das Apfelmännchen, das die
Mandelbrotmenge visualisiert. Das ist die Menge der komplexen Zahlen
$c = x + iy,$ die nicht konvergieren, wenn die Funktion $f_c(z) = z^2 + c$
wiederholt angewendet wird. Also wenn die Folge
$$f_c(0), f_c(f_c(0)), f_c(f_c(f_c(0))), …$$
gegen einen endlichen Wert strebt.</p>
<p>Wenn man jeden Punkt $c$ auf der komplexen Ebene entsprechend des Konvergenzverhaltens
bezüglich dieser Folge einfärbt — schwarz wenn es konvergiert, blau für langsame
Divergenz, rot für schnelle Divergenz — erhält man ein solches Bild:</p>
<p><a href="/img/mandelbrot.png"><img alt="Zoom auf das Apfelmännchen" height="600" src="/img/mandelbrot1200.webp" width="1200"/></a></p>
<p>Dies ist ein Zoom auf den Rand des Apfelmännchens. Tatsächlich ist die
Mandelbrotmenge kein Fraktal im eigentlichen Sinne, da seine fraktale Dimension
2 ist — der schwarze Bereich füllt eine Fläche.</p>
<p>Es einfach möglich dieses Fraktal zu rastern und dabei jeden Pixel parallel zu
berechnen. Eine naive Implementierung könnte wie folgt aussehen.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// convenient iterators</span>
<span class="cp">#[macro_use]</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">itertools</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">itertools</span><span class="p">::</span><span class="n">Itertools</span><span class="p">;</span>

<span class="c1">// parallelism</span>
<span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">rayon</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">rayon</span><span class="p">::</span><span class="n">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="c1">// complex numbers</span>
<span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">num</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">num</span><span class="p">::</span><span class="n">complex</span><span class="p">::</span><span class="n">Complex</span><span class="p">;</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">raster</span><span class="p">(</span><span class="n">resolution</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">))</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resolution</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// generate the points, we want to raster</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pixels</span><span class="p">:</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iproduct</span><span class="o">!</span><span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">x</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// start a parallel iterator on the points ...</span>
<span class="w">    </span><span class="n">pixels</span><span class="p">.</span><span class="n">par_iter</span><span class="p">()</span>
<span class="w">          </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|&amp;</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="c1">// ... mapping every point ...</span>
<span class="w">              </span><span class="kd">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map_to_cplx_plane</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="w">              </span><span class="c1">// ... to the number of iterations needed to diverge</span>
<span class="w">              </span><span class="n">time_to_diverge</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="w">          </span><span class="p">})</span>
<span class="w">          </span><span class="p">.</span><span class="n">collect</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">map_to_cplx_plane</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Complex</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// TODO: here we need to get the offset and scale somehow</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_offset</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x_scale</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">y_offset</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y_scale</span><span class="p">;</span>
<span class="w">    </span><span class="n">Complex</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">re</span><span class="p">:</span><span class="w"> </span><span class="nc">x</span><span class="p">,</span><span class="w"> </span><span class="n">im</span><span class="p">:</span><span class="w"> </span><span class="nc">y</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">time_to_diverge</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">state</span><span class="p">:</span><span class="w"> </span><span class="nc">Complex</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// threshold is 2^2, since we compare to the square of the norm</span>
<span class="w">    </span><span class="c1">// as soon as the norm is &gt;= 2 it is sure to diverge</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// abort after 1000 iterations</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">max_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ctr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="k">u64</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">        </span><span class="n">ctr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="n">state</span><span class="p">.</span><span class="n">norm_sqr</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">threshold</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ctr</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">max_count</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">ctr</span>
<span class="p">}</span>
</code></pre></div>
<h4>Julia-Mengen</h4>
<p>Nahe verwandt sind die Julia-Mengen. Hier benutzt man die gleiche Funktion $f_c$,
allerdings färbt man jeden Punkt $z$ entsprechend seines Konvergenzverhaltens
bei einem festen Parameter $c$.</p>
<p><a href="/img/julia.png"><img alt="Ein Julia-Fraktal" height="675" src="/img/julia1200.webp" width="1200"/></a></p>
<p>Tatsächlich ist jede beliebige Funktion $f$ erlaubt und nicht nur die oben erwähnte
quadratische. Mit unkonventioneller Zuordnung von Farben zu Divergenzzeiten
ergibt sich mit $f(z) = (-2.6-i) \cosh(z)$ dieses Bild:</p>
<p><a href="/img/julia2.png"><img alt="Ein weiteres Julia-Fraktal" height="600" src="/img/julia2_1200.webp" width="1200"/></a></p>
<h4>Newton-Fraktal</h4>
<p>Das <a href="https://de.wikipedia.org/wiki/Newton-Verfahren">Newton-Verfahren zur Findung von Nullstellen</a>
startet an einem beliebigen Punkt auf einer Kurve, und berechnet die Nullstelle
der Tangente an diesem Punkt. Mit der Tangente dieses Punktes wird genauso
verfahren. Dabei sollten sich die so erhaltenen Punkte immer dichter einer
Nullstelle nähern. Bei einer komplexen Funktion können wir dies für jeden
Startpunkt iterieren. Jeder Punkt wird gegen eine Nullstelle konvergieren, der
wir eine Farbe zuordnen und den Punkt mit dieser Farbe einfärben. Wenn wir die
Sättigung davon abhängig machen, wie schnell die Konvergenz ist, sieht das
Ergebnis für $f(x) = z^4 + 5^{z+i} + 15$ so aus.</p>
<p><a href="/img/newton.png"><img alt="Newton Fraktal für f(x) = z^4 + 5^{z+i} + 15" height="675" src="/img/newton1200.webp" width="1200"/></a></p>
<h3>Chaos Game</h3>
<p>Eine große Klasse von Fraktalen lässt sich mit dem Chaos Game erzeugen. Man
benutzt dazu mindestens zwei Abbildungen $f_1(z)$ und $f_2(z)$, die jeweils einen
Punkt $z$ auf einen anderen Punkt abbilden. Man wählt einen Punkt zum Starten,
bildet ihn mit einer Zufälligen der beiden Abbildungen ab, zeichnet den
resultierenden Punkt ein und wiederholt dies sehr oft.</p>
<p>Dieser Algorithmus ist inherent sequenziell, allerdings kann man parallel an
vielen verschiedenen Punkten starten und die Ergebnisse dieser unabhängigen
Markovketten in einem Bild zusammenführen.</p>
<p>In Rust könnte der entsprechende Codeschnipsel so aussehen:</p>
<div class="highlight"><pre><span></span><code><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">num_cpus</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">sync</span><span class="p">::</span><span class="n">mpsc</span><span class="p">::</span><span class="n">channel</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="n">cpus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_cpus</span><span class="p">::</span><span class="n">get</span><span class="p">();</span>

<span class="c1">// create a transmitter, receiver pair</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channel</span><span class="p">();</span>
<span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">cpus</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// clone a transmitter for each thread</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tx</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// generator yielding the points from the chaos game</span>
<span class="w">    </span><span class="c1">// using a random seed</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sampler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_sampler</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// we need some histogram implementation</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">hist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Histogram</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>

<span class="w">    </span><span class="n">thread</span><span class="p">::</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// feed the samples into the histogram</span>
<span class="w">        </span><span class="n">hist</span><span class="p">.</span><span class="n">feed</span><span class="p">(</span><span class="n">sampler</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="n">iterations_per_task</span><span class="p">));</span>
<span class="w">        </span><span class="c1">// send the finished histogram to the receiver</span>
<span class="w">        </span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">hist</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>

<span class="c1">// collect all parallel computed histograms into main_hist</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">main_hist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Histogram</span><span class="p">::</span><span class="n">new</span><span class="p">();</span>
<span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">cpus</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">recv</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="n">main_hist</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4>Sierpinski-Dreieck und Barnsley-Farn</h4>
<p>Mit dieser Methode kann man alte Bekannte wie das <a href="https://blog.schawe.me/rule-90.html">Sierpinski-Dreieck</a> erzeugen.</p>
<p><a href="/img/sierpinski.png"><img alt="Sierpinski-Dreieck" height="897" src="/img/sierpinski.png" width="1005"/></a></p>
<p>Dazu benötigt man die drei affinen Transformationen, die man alle mit gleicher
Wahrscheinlichkeit auswählt:
$$\begin{align}
f_1(\vec z) &amp;=\begin{pmatrix}
            -1/4         <span class="amp">&amp;</span> \sqrt 3 / 4 \
            -\sqrt 3 / 4 <span class="amp">&amp;</span> -1/4
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            z_x \
            z_y
        \end{pmatrix}
        +
        \begin{pmatrix}
                -1/4\
                \sqrt 3 / 4
        \end{pmatrix}\
f_2(\vec z) &amp;=\begin{pmatrix}
            1/2 <span class="amp">&amp;</span> 0 \
            0   <span class="amp">&amp;</span> 1/2
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            z_x \
            z_y
        \end{pmatrix}
        +
        \begin{pmatrix}
                1/4\
                \sqrt 3 / 4
        \end{pmatrix}\
f_3(\vec z) &amp;=\begin{pmatrix}
            -1/4 <span class="amp">&amp;</span> -\sqrt 3 / 4 \
            \sqrt 3 / 4   <span class="amp">&amp;</span> 1/4
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            z_x \
            z_y
        \end{pmatrix}
        +
        \begin{pmatrix}
                1\
                0
        \end{pmatrix} \end{align}$$</p>
<p>Ein anderes berühmtes Beispiel ist der Barnsley-Farn. Um ihn zu erzeugen, benutzt
man die folgenden vier affinen Abbildungen, die man mit den Wahrscheinlichkeiten
$$p_1 = 0.01, p_2 = 0.85, p_3 = 0.07, p_4 = 0.07$$
verwendet:
$$\begin{align}
f_1(z) &amp;=\begin{pmatrix}
                0.16\
                0
        \end{pmatrix}\
f_2(z) &amp;=\begin{pmatrix}
            0.85 <span class="amp">&amp;</span> 0.04 \
            0    <span class="amp">&amp;</span> -0.04
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            z_x \
            z_y
        \end{pmatrix}
        +
        \begin{pmatrix}
                0.85\
                1.6
        \end{pmatrix}\
f_3(z) &amp;=\begin{pmatrix}
            0.2 <span class="amp">&amp;</span> -0.26 \
            0   <span class="amp">&amp;</span> 0.23
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            z_x \
            z_y
        \end{pmatrix}
        +
        \begin{pmatrix}
                0.22\
                1.6
        \end{pmatrix}\
f_4(z) &amp;=\begin{pmatrix}
            -0.15 <span class="amp">&amp;</span> 0.28 \
            0     <span class="amp">&amp;</span> 0.26
        \end{pmatrix}
        \cdot
        \begin{pmatrix}
            z_x \
            z_y
        \end{pmatrix}
        +
        \begin{pmatrix}
                0.24\
                0.44
        \end{pmatrix}\ \end{align}$$</p>
<p>Als Ergebnis erhält man diesen Farn.</p>
<p><a href="/img/fern.png"><img alt="Bernsley-Farn" height="1022" src="/img/fern.png" width="582"/></a></p>
<h4>Fractal Flame</h4>
<p><a href="http://flam3.com/flame_draves.pdf">Fractal Flame</a> ist der Name einer Klasse
von Zufallsfraktalen, die nach dem gleichen Muster wie oben aus einer Reihe
affiner Transformationen $A_i$ bestehen. Zusätzlich können die affinen
Transformationen mit einer nichtlinearen <em>Variation</em> $V_j$ erweitert werden,
sodass $f_i(\vec z) = V_j(A_i(\vec z))$ (oder Linearkombinationen dieser Variationen).
Zur Visualisierung werden die Punkte nicht direkt gezeichnet, sondern in ein
Histogramm eingetragen, aus dem die Farbintensitäten typischerweise
logarithmisch berechnet werden.</p>
<p><a href="/img/horseshoe.png"><img alt="Fractal Flame, 'Horseshoe' Variation" height="1022" src="/img/horseshoe1200.webp" width="1143"/></a></p>
<p>Hier wird jedem $f_i$ ein Farbton zugeordnet. Die Farbe eines Punktes ist eine
Mischung dieser Farben, die widerspiegelt, wie oft eine Abbildung genutzt wurde,
um an diesen Punkt zu gelangen.</p>
<p>Interessanterweise sind diese Systeme anscheinend sehr anfällig für schlechte
Zufallszahlen, was sich in „Löchern“ in den ansonsten glatten Flächen bemerkbar macht.</p>
<h4>Möbius Flame</h4>
<p>Diese Fraktale sind nahezu identisch zu den Fractal Flames, nur dass anstatt von
affinen Transformationen Möbius Transformationen auf der komplexen Ebene genutzt werden.</p>
<p>$$f_i(z) = \frac{a_i z + b_i}{c_i z + d_i}$$</p>
<p><a href="/img/mobius.png"><img alt="Möbius Flame" height="599" src="/img/mobius1200.webp" width="1200"/></a></p>
<h4>Wie findet man „gute“ Parameter?</h4>
<p>Offenbar hat dieser Typ von Fraktal sehr viele freie Parameter. Um hübsche
Resultate zu generieren, müssen sie angepasst werden. Tatsächlich gibt es mit
<a href="https://electricsheep.org/">electric sheep</a> (ich hoffe stark, dass es eine
<a href="https://de.wikipedia.org/wiki/Tr%C3%A4umen_Androiden_von_elektrischen_Schafen%3F">Blade Runner</a>
Referenz ist) ein Crowdsourcing-Projekt,
das mithilfe von evolutionären Algorithmen und dem Feedback von Menschen
besonders ansehnliche Fraktale erzeugt.</p>
<p>Für mein Programm habe ich eine simplere Methode genutzt. Damit man ein Fraktal
gut sehen kann, sollte seine fraktale Dimension größer als 1 sein. Abschätzbar
ist es relativ einfach über die <a href="https://en.wikipedia.org/wiki/Correlation_dimension">Korrelations-Dimension</a>.
Dazu misst man die paarweisen Abstände von Punkten und misst den Exponenten ihrer
kumulativen Verteilungsfunktion.</p>
<p>Kombiniert mit einigen Heuristiken, die zu langgestreckte Fraktale verhindert,
sind die Ergebnisse meist ansprechend</p>
<h3>Weitere Fraktale</h3>
<p>Es gibt natürlich viel mehr Typen von Fraktalen. Auch wenn <a href="https://twitter.com/AFractalADay">@AFractalADay</a>
sie bisher nicht zeichnen kann, habe ich einige Bilder angefertigt, die ich
hier auch gerne zeigen möchte.</p>
<h4>Diffusionsbegrenztes Wachstum</h4>
<p>Diffusionsbegrenztes Wachstum bildet das Wachstum von Kristallen in stark
verdünnten Lösungen ab. Man startet mit einem Seed und lässt dann einzelne
Teilchen diffundieren, bis sie auf dem Nachbarfeld eines Seeds landen, wo sie
dann bleiben und Teil des Seeds werden. Dieser Prozess bildet verästelte
Strukturen aus.</p>
<p><a href="/img/dla_core.png"><img alt="Diffusionsbegrenztes Wachstum" height="1200" src="/img/dla_core1200.webp" width="1200"/></a></p>
<h4>Random Walks</h4>
<p>Einige Arten von Random Walks haben eine fraktale Dimension zwischen 1 und 2,
was sie zu ansehnlichen Fraktalen machen sollte. Der Smart Kinetic Self
Avoiding Walk, der in meinem <a href="https://blog.schawe.me/rsnake.html">rsnake</a> die Strategie des
Autopiloten ist, hat eine fraktale Dimension von $\frac{7}{4}$. 100000 Schritte
sehen so aus:</p>
<p><a class="invertable" href="/img/sksaw.png"><img alt="Smart Kinetic Self Avoiding Walk, 100000 Schritte" height="1275" src="/img/sksaw1200.webp" width="1200"/></a></p>
</div>
</article>
<article class="post">
<header>
<h2 class="post-title">
<a href="https://blog.schawe.me/vicsek.html"> Vicsek  </a>
</h2>
<div class="post-meta">
<time class="post-time" datetime="2017-08-08T21:46:00+02:00">08.08.2017</time>
<span class="category category-code">
<a href="https://blog.schawe.me/categories.html#code-ref">Code</a>
</span>
<span class="tags-in-article">
<span class="tag">
<a href="https://blog.schawe.me/tags.html#bild-ref">Bild</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#code-ref">Code</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#physik-ref">Physik</a>
</span>
<span class="tag">
<a href="https://blog.schawe.me/tags.html#rust-ref">Rust</a>
</span>
</span>
</div>
</header>
<div class="post-content">
<p>Das <a href="https://doi.org/10.1103/PhysRevLett.75.1226">Vicsek-Modell</a> wurde 1995
vorgeschlagen, um das Schwarmverhalten von Vögeln oder Fischen zu modellieren.
Die Idee ist, dass jedes Individuum seine Bewegungsrichtung an der seiner
Nachbarn anpasst. Wenn jedes Individuum genügend Nachbarn hat und die
Störeinflüsse nicht zu groß sind, bilden sich Schwärme. Videos von solchen
Schwärmen werden auf allen größeren Konferenzen der Statistischen Physik
gezeigt — und jetzt auch hier.</p>
<video autoplay="" controls="" loop="" poster="/img/vicsek.png">
<source src="/vid/vicsek.mp4" type="video/mp4"/>
Your browser does not support the video tag.
</video>
<p>Auf <a href="https://github.com/surt91/vicsek">GitHub</a> findet sich das Programm,
das ich für obiges Video geschrieben habe. Es ist in Rust geschrieben und
zeigt die Simulation per Piston auf dem Bildschirm.</p>
<p>Ich habe sehr großen Gefallen an Rust gefunden — gerade für ein Projekt wie
dieses scheint es ideal geeignet. Es ist so schnell wie C, aber man muss sich
keinerlei Gedanken um den Speicher machen und einige andere Fehlerklassen, die
der Compiler direkt verhindert. Rayon macht Parallelisierung so einfach wie
OpenMP — mit dem Vorteil, dass der Compiler einen Fehler ausgibt, falls es
eine Variable gibt, aus der parallel gelesen und geschrieben wird.</p>
<p>Als Beispiel, warum ich Rust als sehr leserlich und elegant empfinde, möchte
ich folgendes (unvollständige) Beispiel ansehen.</p>
<div class="highlight"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="nc">Proximity</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Neighbors</span><span class="p">(</span><span class="kt">usize</span><span class="p">),</span>
<span class="w">    </span><span class="n">Radius</span><span class="p">(</span><span class="kt">f64</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Vicsek</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">proximity</span><span class="p">:</span><span class="w"> </span><span class="nc">Proximity</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Vicsek</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="n">bird</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Bird</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">proximity</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Proximity</span><span class="p">::</span><span class="n">Neighbors</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">update_direction_neighbors</span><span class="p">(</span><span class="n">bird</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">noise</span><span class="p">),</span>
<span class="w">            </span><span class="n">Proximity</span><span class="p">::</span><span class="n">Radius</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">update_direction_disk</span><span class="p">(</span><span class="n">bird</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">noise</span><span class="p">),</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Die Methode <code>update()</code> passt die Richtung an, in die ihr Argument im nächsten
Zeitschritt fliegen soll. In meiner Simulation gibt es zwei Möglichkeiten:
entweder orientiert man sich an seinen <code>n</code> nächsten Nachbarn oder an allen
Vögeln innerhalb eines Radius von <code>r</code>. Der Datentyp <code>Proximity</code> kann eines von
beiden beinhalten — welches vorhanden ist, kann elegant per Pattern-Matching
ermittelt werden.</p>
<p>Brauche ich länger, um Rust zu schreiben als C oder C++? Vermutlich, aber ich
verbringe weniger Zeit mit dem Debuggen. Netto also mehr Spaß.</p>
</div>
</article>
</div>
<div class="post-navigation">
<nav class="pagination">
<a href="https://blog.schawe.me/tag/physik.html">← Neuer</a>
<span class="separatordot">·</span>
<a href="https://blog.schawe.me/tag/physik3.html">Älter →</a>
<br/>
            2 / 5
        </nav>
</div>
</div>
<div id="last-update">
<time datetime="2025-10-29 22:34:37">22:34:37 29.10.2025</time>
</div>
</div>
<script async="" src="/theme/webassets-external/0cf7968c252ead5c096e55c1f7673096_rythm.js"></script>
<script async="" src="/theme/webassets-external/a8b690a4c23c0610ea6538a9352534be_totally_serious_script.js"></script>
<script async="" src="/theme/js/unregister_service_worker.js"></script>
</body>
</html>